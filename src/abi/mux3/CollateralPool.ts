/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../common";

export type MarketStateStruct = {
  isLong: PromiseOrValue<boolean>;
  totalSize: PromiseOrValue<BigNumberish>;
  averageEntryPrice: PromiseOrValue<BigNumberish>;
  cumulatedBorrowingPerUsd: PromiseOrValue<BigNumberish>;
  lastBorrowingUpdateTime: PromiseOrValue<BigNumberish>;
};

export type MarketStateStructOutput = [
  boolean,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber
] & {
  isLong: boolean;
  totalSize: BigNumber;
  averageEntryPrice: BigNumber;
  cumulatedBorrowingPerUsd: BigNumber;
  lastBorrowingUpdateTime: BigNumber;
};

export declare namespace ICollateralPool {
  export type AddLiquidityArgsStruct = {
    account: PromiseOrValue<string>;
    rawCollateralAmount: PromiseOrValue<BigNumberish>;
    isUnwrapWeth: PromiseOrValue<boolean>;
  };

  export type AddLiquidityArgsStructOutput = [string, BigNumber, boolean] & {
    account: string;
    rawCollateralAmount: BigNumber;
    isUnwrapWeth: boolean;
  };

  export type AddLiquidityResultStruct = {
    shares: PromiseOrValue<BigNumberish>;
    collateralPrice: PromiseOrValue<BigNumberish>;
    lpPrice: PromiseOrValue<BigNumberish>;
  };

  export type AddLiquidityResultStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber
  ] & { shares: BigNumber; collateralPrice: BigNumber; lpPrice: BigNumber };

  export type RemoveLiquidityArgsStruct = {
    account: PromiseOrValue<string>;
    shares: PromiseOrValue<BigNumberish>;
    token: PromiseOrValue<string>;
    isUnwrapWeth: PromiseOrValue<boolean>;
    extraFeeCollateral: PromiseOrValue<BigNumberish>;
  };

  export type RemoveLiquidityArgsStructOutput = [
    string,
    BigNumber,
    string,
    boolean,
    BigNumber
  ] & {
    account: string;
    shares: BigNumber;
    token: string;
    isUnwrapWeth: boolean;
    extraFeeCollateral: BigNumber;
  };

  export type RemoveLiquidityResultStruct = {
    rawCollateralAmount: PromiseOrValue<BigNumberish>;
    collateralPrice: PromiseOrValue<BigNumberish>;
    lpPrice: PromiseOrValue<BigNumberish>;
  };

  export type RemoveLiquidityResultStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    rawCollateralAmount: BigNumber;
    collateralPrice: BigNumber;
    lpPrice: BigNumber;
  };
}

export declare namespace IBorrowingRate {
  export type AllocatePoolStruct = {
    poolId: PromiseOrValue<BigNumberish>;
    k: PromiseOrValue<BigNumberish>;
    b: PromiseOrValue<BigNumberish>;
    poolSizeUsd: PromiseOrValue<BigNumberish>;
    reservedUsd: PromiseOrValue<BigNumberish>;
    reserveRate: PromiseOrValue<BigNumberish>;
    isDraining: PromiseOrValue<boolean>;
  };

  export type AllocatePoolStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    boolean
  ] & {
    poolId: BigNumber;
    k: BigNumber;
    b: BigNumber;
    poolSizeUsd: BigNumber;
    reservedUsd: BigNumber;
    reserveRate: BigNumber;
    isDraining: boolean;
  };
}

export interface CollateralPoolInterface extends utils.Interface {
  functions: {
    "addLiquidity((address,uint256,bool))": FunctionFragment;
    "allowance(address,address)": FunctionFragment;
    "approve(address,uint256)": FunctionFragment;
    "balanceOf(address)": FunctionFragment;
    "borrowingFeeRateApy(bytes32)": FunctionFragment;
    "closePosition(bytes32,uint256,uint256)": FunctionFragment;
    "collateralToken()": FunctionFragment;
    "configValue(bytes32)": FunctionFragment;
    "decimals()": FunctionFragment;
    "decreaseAllowance(address,uint256)": FunctionFragment;
    "getAumUsd()": FunctionFragment;
    "getCollateralTokenUsd()": FunctionFragment;
    "getReservedUsd()": FunctionFragment;
    "increaseAllowance(address,uint256)": FunctionFragment;
    "initialize(string,string,address)": FunctionFragment;
    "liquidityBalances()": FunctionFragment;
    "makeBorrowingContext(bytes32)": FunctionFragment;
    "marketConfigs(bytes32[])": FunctionFragment;
    "marketState(bytes32)": FunctionFragment;
    "marketStates()": FunctionFragment;
    "markets()": FunctionFragment;
    "name()": FunctionFragment;
    "openPosition(bytes32,uint256,uint256)": FunctionFragment;
    "positionPnl(bytes32,uint256,uint256,uint256)": FunctionFragment;
    "realizeLoss(address,uint256)": FunctionFragment;
    "realizeProfit(uint256)": FunctionFragment;
    "rebalance(address,address,uint256,uint256,bytes)": FunctionFragment;
    "receiveFee(address,uint256)": FunctionFragment;
    "removeLiquidity((address,uint256,address,bool,uint256))": FunctionFragment;
    "setConfig(bytes32,bytes32)": FunctionFragment;
    "setMarket(bytes32,bool)": FunctionFragment;
    "symbol()": FunctionFragment;
    "totalSupply()": FunctionFragment;
    "transfer(address,uint256)": FunctionFragment;
    "transferFrom(address,address,uint256)": FunctionFragment;
    "updateMarketBorrowing(bytes32)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "addLiquidity"
      | "allowance"
      | "approve"
      | "balanceOf"
      | "borrowingFeeRateApy"
      | "closePosition"
      | "collateralToken"
      | "configValue"
      | "decimals"
      | "decreaseAllowance"
      | "getAumUsd"
      | "getCollateralTokenUsd"
      | "getReservedUsd"
      | "increaseAllowance"
      | "initialize"
      | "liquidityBalances"
      | "makeBorrowingContext"
      | "marketConfigs"
      | "marketState"
      | "marketStates"
      | "markets"
      | "name"
      | "openPosition"
      | "positionPnl"
      | "realizeLoss"
      | "realizeProfit"
      | "rebalance"
      | "receiveFee"
      | "removeLiquidity"
      | "setConfig"
      | "setMarket"
      | "symbol"
      | "totalSupply"
      | "transfer"
      | "transferFrom"
      | "updateMarketBorrowing"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "addLiquidity",
    values: [ICollateralPool.AddLiquidityArgsStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "allowance",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "approve",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "balanceOf",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "borrowingFeeRateApy",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "closePosition",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "collateralToken",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "configValue",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(functionFragment: "decimals", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "decreaseAllowance",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: "getAumUsd", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "getCollateralTokenUsd",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getReservedUsd",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "increaseAllowance",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "liquidityBalances",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "makeBorrowingContext",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "marketConfigs",
    values: [PromiseOrValue<BytesLike>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "marketState",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "marketStates",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "markets", values?: undefined): string;
  encodeFunctionData(functionFragment: "name", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "openPosition",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "positionPnl",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "realizeLoss",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "realizeProfit",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "rebalance",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "receiveFee",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "removeLiquidity",
    values: [ICollateralPool.RemoveLiquidityArgsStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "setConfig",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "setMarket",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(functionFragment: "symbol", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "totalSupply",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "transfer",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "transferFrom",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "updateMarketBorrowing",
    values: [PromiseOrValue<BytesLike>]
  ): string;

  decodeFunctionResult(
    functionFragment: "addLiquidity",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "allowance", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "approve", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "borrowingFeeRateApy",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "closePosition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "collateralToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "configValue",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "decimals", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "decreaseAllowance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getAumUsd", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getCollateralTokenUsd",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getReservedUsd",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "increaseAllowance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "liquidityBalances",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "makeBorrowingContext",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "marketConfigs",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "marketState",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "marketStates",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "markets", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "name", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "openPosition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "positionPnl",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "realizeLoss",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "realizeProfit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "rebalance", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "receiveFee", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "removeLiquidity",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setConfig", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "setMarket", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "symbol", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "totalSupply",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "transfer", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "transferFrom",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateMarketBorrowing",
    data: BytesLike
  ): Result;

  events: {
    "Approval(address,address,uint256)": EventFragment;
    "Initialized(uint8)": EventFragment;
    "SetValue(bytes32,bytes32)": EventFragment;
    "Transfer(address,address,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "Approval"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Initialized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetValue"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Transfer"): EventFragment;
}

export interface ApprovalEventObject {
  owner: string;
  spender: string;
  value: BigNumber;
}
export type ApprovalEvent = TypedEvent<
  [string, string, BigNumber],
  ApprovalEventObject
>;

export type ApprovalEventFilter = TypedEventFilter<ApprovalEvent>;

export interface InitializedEventObject {
  version: number;
}
export type InitializedEvent = TypedEvent<[number], InitializedEventObject>;

export type InitializedEventFilter = TypedEventFilter<InitializedEvent>;

export interface SetValueEventObject {
  key: string;
  value: string;
}
export type SetValueEvent = TypedEvent<[string, string], SetValueEventObject>;

export type SetValueEventFilter = TypedEventFilter<SetValueEvent>;

export interface TransferEventObject {
  from: string;
  to: string;
  value: BigNumber;
}
export type TransferEvent = TypedEvent<
  [string, string, BigNumber],
  TransferEventObject
>;

export type TransferEventFilter = TypedEventFilter<TransferEvent>;

export interface CollateralPool extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: CollateralPoolInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    addLiquidity(
      args: ICollateralPool.AddLiquidityArgsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    allowance(
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    approve(
      spender: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    balanceOf(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    borrowingFeeRateApy(
      marketId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { feeRateApy: BigNumber }>;

    closePosition(
      marketId: PromiseOrValue<BytesLike>,
      size: PromiseOrValue<BigNumberish>,
      entryPrice: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    collateralToken(overrides?: CallOverrides): Promise<[string]>;

    configValue(
      key: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    decimals(overrides?: CallOverrides): Promise<[number]>;

    decreaseAllowance(
      spender: PromiseOrValue<string>,
      subtractedValue: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getAumUsd(overrides?: CallOverrides): Promise<[BigNumber]>;

    getCollateralTokenUsd(overrides?: CallOverrides): Promise<[BigNumber]>;

    getReservedUsd(overrides?: CallOverrides): Promise<[BigNumber]>;

    increaseAllowance(
      spender: PromiseOrValue<string>,
      addedValue: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    initialize(
      name_: PromiseOrValue<string>,
      symbol_: PromiseOrValue<string>,
      collateralToken_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    liquidityBalances(
      overrides?: CallOverrides
    ): Promise<
      [string[], BigNumber[]] & { tokens: string[]; balances: BigNumber[] }
    >;

    makeBorrowingContext(
      marketId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<
      [IBorrowingRate.AllocatePoolStructOutput] & {
        poolFr: IBorrowingRate.AllocatePoolStructOutput;
      }
    >;

    marketConfigs(
      keyPrefixes: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<
      [string[], string[][]] & { marketIds: string[]; values: string[][] }
    >;

    marketState(
      marketId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[MarketStateStructOutput]>;

    marketStates(
      overrides?: CallOverrides
    ): Promise<
      [string[], MarketStateStructOutput[]] & {
        marketIds: string[];
        states: MarketStateStructOutput[];
      }
    >;

    markets(overrides?: CallOverrides): Promise<[string[]]>;

    name(overrides?: CallOverrides): Promise<[string]>;

    openPosition(
      marketId: PromiseOrValue<BytesLike>,
      size: PromiseOrValue<BigNumberish>,
      entryPrice: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    positionPnl(
      marketId: PromiseOrValue<BytesLike>,
      size: PromiseOrValue<BigNumberish>,
      entryPrice: PromiseOrValue<BigNumberish>,
      marketPrice: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { pnlUsd: BigNumber; cappedPnlUsd: BigNumber }
    >;

    realizeLoss(
      token: PromiseOrValue<string>,
      rawAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    realizeProfit(
      pnlUsd: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    rebalance(
      rebalancer: PromiseOrValue<string>,
      token0: PromiseOrValue<string>,
      rawAmount0: PromiseOrValue<BigNumberish>,
      maxRawAmount1: PromiseOrValue<BigNumberish>,
      userData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    receiveFee(
      token: PromiseOrValue<string>,
      rawAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    removeLiquidity(
      args: ICollateralPool.RemoveLiquidityArgsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setConfig(
      key: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setMarket(
      marketId: PromiseOrValue<BytesLike>,
      isLong: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    symbol(overrides?: CallOverrides): Promise<[string]>;

    totalSupply(overrides?: CallOverrides): Promise<[BigNumber]>;

    transfer(
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    transferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updateMarketBorrowing(
      marketId: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  addLiquidity(
    args: ICollateralPool.AddLiquidityArgsStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  allowance(
    owner: PromiseOrValue<string>,
    spender: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  approve(
    spender: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  balanceOf(
    account: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  borrowingFeeRateApy(
    marketId: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  closePosition(
    marketId: PromiseOrValue<BytesLike>,
    size: PromiseOrValue<BigNumberish>,
    entryPrice: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  collateralToken(overrides?: CallOverrides): Promise<string>;

  configValue(
    key: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<string>;

  decimals(overrides?: CallOverrides): Promise<number>;

  decreaseAllowance(
    spender: PromiseOrValue<string>,
    subtractedValue: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getAumUsd(overrides?: CallOverrides): Promise<BigNumber>;

  getCollateralTokenUsd(overrides?: CallOverrides): Promise<BigNumber>;

  getReservedUsd(overrides?: CallOverrides): Promise<BigNumber>;

  increaseAllowance(
    spender: PromiseOrValue<string>,
    addedValue: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  initialize(
    name_: PromiseOrValue<string>,
    symbol_: PromiseOrValue<string>,
    collateralToken_: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  liquidityBalances(
    overrides?: CallOverrides
  ): Promise<
    [string[], BigNumber[]] & { tokens: string[]; balances: BigNumber[] }
  >;

  makeBorrowingContext(
    marketId: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<IBorrowingRate.AllocatePoolStructOutput>;

  marketConfigs(
    keyPrefixes: PromiseOrValue<BytesLike>[],
    overrides?: CallOverrides
  ): Promise<
    [string[], string[][]] & { marketIds: string[]; values: string[][] }
  >;

  marketState(
    marketId: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<MarketStateStructOutput>;

  marketStates(
    overrides?: CallOverrides
  ): Promise<
    [string[], MarketStateStructOutput[]] & {
      marketIds: string[];
      states: MarketStateStructOutput[];
    }
  >;

  markets(overrides?: CallOverrides): Promise<string[]>;

  name(overrides?: CallOverrides): Promise<string>;

  openPosition(
    marketId: PromiseOrValue<BytesLike>,
    size: PromiseOrValue<BigNumberish>,
    entryPrice: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  positionPnl(
    marketId: PromiseOrValue<BytesLike>,
    size: PromiseOrValue<BigNumberish>,
    entryPrice: PromiseOrValue<BigNumberish>,
    marketPrice: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber] & { pnlUsd: BigNumber; cappedPnlUsd: BigNumber }
  >;

  realizeLoss(
    token: PromiseOrValue<string>,
    rawAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  realizeProfit(
    pnlUsd: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  rebalance(
    rebalancer: PromiseOrValue<string>,
    token0: PromiseOrValue<string>,
    rawAmount0: PromiseOrValue<BigNumberish>,
    maxRawAmount1: PromiseOrValue<BigNumberish>,
    userData: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  receiveFee(
    token: PromiseOrValue<string>,
    rawAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  removeLiquidity(
    args: ICollateralPool.RemoveLiquidityArgsStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setConfig(
    key: PromiseOrValue<BytesLike>,
    value: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setMarket(
    marketId: PromiseOrValue<BytesLike>,
    isLong: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  symbol(overrides?: CallOverrides): Promise<string>;

  totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

  transfer(
    to: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  transferFrom(
    from: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updateMarketBorrowing(
    marketId: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    addLiquidity(
      args: ICollateralPool.AddLiquidityArgsStruct,
      overrides?: CallOverrides
    ): Promise<ICollateralPool.AddLiquidityResultStructOutput>;

    allowance(
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    approve(
      spender: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    balanceOf(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    borrowingFeeRateApy(
      marketId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    closePosition(
      marketId: PromiseOrValue<BytesLike>,
      size: PromiseOrValue<BigNumberish>,
      entryPrice: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    collateralToken(overrides?: CallOverrides): Promise<string>;

    configValue(
      key: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    decimals(overrides?: CallOverrides): Promise<number>;

    decreaseAllowance(
      spender: PromiseOrValue<string>,
      subtractedValue: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    getAumUsd(overrides?: CallOverrides): Promise<BigNumber>;

    getCollateralTokenUsd(overrides?: CallOverrides): Promise<BigNumber>;

    getReservedUsd(overrides?: CallOverrides): Promise<BigNumber>;

    increaseAllowance(
      spender: PromiseOrValue<string>,
      addedValue: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    initialize(
      name_: PromiseOrValue<string>,
      symbol_: PromiseOrValue<string>,
      collateralToken_: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    liquidityBalances(
      overrides?: CallOverrides
    ): Promise<
      [string[], BigNumber[]] & { tokens: string[]; balances: BigNumber[] }
    >;

    makeBorrowingContext(
      marketId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<IBorrowingRate.AllocatePoolStructOutput>;

    marketConfigs(
      keyPrefixes: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<
      [string[], string[][]] & { marketIds: string[]; values: string[][] }
    >;

    marketState(
      marketId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<MarketStateStructOutput>;

    marketStates(
      overrides?: CallOverrides
    ): Promise<
      [string[], MarketStateStructOutput[]] & {
        marketIds: string[];
        states: MarketStateStructOutput[];
      }
    >;

    markets(overrides?: CallOverrides): Promise<string[]>;

    name(overrides?: CallOverrides): Promise<string>;

    openPosition(
      marketId: PromiseOrValue<BytesLike>,
      size: PromiseOrValue<BigNumberish>,
      entryPrice: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    positionPnl(
      marketId: PromiseOrValue<BytesLike>,
      size: PromiseOrValue<BigNumberish>,
      entryPrice: PromiseOrValue<BigNumberish>,
      marketPrice: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { pnlUsd: BigNumber; cappedPnlUsd: BigNumber }
    >;

    realizeLoss(
      token: PromiseOrValue<string>,
      rawAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    realizeProfit(
      pnlUsd: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string, BigNumber] & { token: string; wad: BigNumber }>;

    rebalance(
      rebalancer: PromiseOrValue<string>,
      token0: PromiseOrValue<string>,
      rawAmount0: PromiseOrValue<BigNumberish>,
      maxRawAmount1: PromiseOrValue<BigNumberish>,
      userData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    receiveFee(
      token: PromiseOrValue<string>,
      rawAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    removeLiquidity(
      args: ICollateralPool.RemoveLiquidityArgsStruct,
      overrides?: CallOverrides
    ): Promise<ICollateralPool.RemoveLiquidityResultStructOutput>;

    setConfig(
      key: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    setMarket(
      marketId: PromiseOrValue<BytesLike>,
      isLong: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    symbol(overrides?: CallOverrides): Promise<string>;

    totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

    transfer(
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    transferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    updateMarketBorrowing(
      marketId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  filters: {
    "Approval(address,address,uint256)"(
      owner?: PromiseOrValue<string> | null,
      spender?: PromiseOrValue<string> | null,
      value?: null
    ): ApprovalEventFilter;
    Approval(
      owner?: PromiseOrValue<string> | null,
      spender?: PromiseOrValue<string> | null,
      value?: null
    ): ApprovalEventFilter;

    "Initialized(uint8)"(version?: null): InitializedEventFilter;
    Initialized(version?: null): InitializedEventFilter;

    "SetValue(bytes32,bytes32)"(key?: null, value?: null): SetValueEventFilter;
    SetValue(key?: null, value?: null): SetValueEventFilter;

    "Transfer(address,address,uint256)"(
      from?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      value?: null
    ): TransferEventFilter;
    Transfer(
      from?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      value?: null
    ): TransferEventFilter;
  };

  estimateGas: {
    addLiquidity(
      args: ICollateralPool.AddLiquidityArgsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    allowance(
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    approve(
      spender: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    balanceOf(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    borrowingFeeRateApy(
      marketId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    closePosition(
      marketId: PromiseOrValue<BytesLike>,
      size: PromiseOrValue<BigNumberish>,
      entryPrice: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    collateralToken(overrides?: CallOverrides): Promise<BigNumber>;

    configValue(
      key: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    decimals(overrides?: CallOverrides): Promise<BigNumber>;

    decreaseAllowance(
      spender: PromiseOrValue<string>,
      subtractedValue: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getAumUsd(overrides?: CallOverrides): Promise<BigNumber>;

    getCollateralTokenUsd(overrides?: CallOverrides): Promise<BigNumber>;

    getReservedUsd(overrides?: CallOverrides): Promise<BigNumber>;

    increaseAllowance(
      spender: PromiseOrValue<string>,
      addedValue: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    initialize(
      name_: PromiseOrValue<string>,
      symbol_: PromiseOrValue<string>,
      collateralToken_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    liquidityBalances(overrides?: CallOverrides): Promise<BigNumber>;

    makeBorrowingContext(
      marketId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    marketConfigs(
      keyPrefixes: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    marketState(
      marketId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    marketStates(overrides?: CallOverrides): Promise<BigNumber>;

    markets(overrides?: CallOverrides): Promise<BigNumber>;

    name(overrides?: CallOverrides): Promise<BigNumber>;

    openPosition(
      marketId: PromiseOrValue<BytesLike>,
      size: PromiseOrValue<BigNumberish>,
      entryPrice: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    positionPnl(
      marketId: PromiseOrValue<BytesLike>,
      size: PromiseOrValue<BigNumberish>,
      entryPrice: PromiseOrValue<BigNumberish>,
      marketPrice: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    realizeLoss(
      token: PromiseOrValue<string>,
      rawAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    realizeProfit(
      pnlUsd: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    rebalance(
      rebalancer: PromiseOrValue<string>,
      token0: PromiseOrValue<string>,
      rawAmount0: PromiseOrValue<BigNumberish>,
      maxRawAmount1: PromiseOrValue<BigNumberish>,
      userData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    receiveFee(
      token: PromiseOrValue<string>,
      rawAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    removeLiquidity(
      args: ICollateralPool.RemoveLiquidityArgsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setConfig(
      key: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setMarket(
      marketId: PromiseOrValue<BytesLike>,
      isLong: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    symbol(overrides?: CallOverrides): Promise<BigNumber>;

    totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

    transfer(
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    transferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updateMarketBorrowing(
      marketId: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    addLiquidity(
      args: ICollateralPool.AddLiquidityArgsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    allowance(
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    approve(
      spender: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    balanceOf(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    borrowingFeeRateApy(
      marketId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    closePosition(
      marketId: PromiseOrValue<BytesLike>,
      size: PromiseOrValue<BigNumberish>,
      entryPrice: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    collateralToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    configValue(
      key: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    decimals(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    decreaseAllowance(
      spender: PromiseOrValue<string>,
      subtractedValue: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getAumUsd(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getCollateralTokenUsd(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getReservedUsd(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    increaseAllowance(
      spender: PromiseOrValue<string>,
      addedValue: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    initialize(
      name_: PromiseOrValue<string>,
      symbol_: PromiseOrValue<string>,
      collateralToken_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    liquidityBalances(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    makeBorrowingContext(
      marketId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    marketConfigs(
      keyPrefixes: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    marketState(
      marketId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    marketStates(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    markets(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    name(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    openPosition(
      marketId: PromiseOrValue<BytesLike>,
      size: PromiseOrValue<BigNumberish>,
      entryPrice: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    positionPnl(
      marketId: PromiseOrValue<BytesLike>,
      size: PromiseOrValue<BigNumberish>,
      entryPrice: PromiseOrValue<BigNumberish>,
      marketPrice: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    realizeLoss(
      token: PromiseOrValue<string>,
      rawAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    realizeProfit(
      pnlUsd: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    rebalance(
      rebalancer: PromiseOrValue<string>,
      token0: PromiseOrValue<string>,
      rawAmount0: PromiseOrValue<BigNumberish>,
      maxRawAmount1: PromiseOrValue<BigNumberish>,
      userData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    receiveFee(
      token: PromiseOrValue<string>,
      rawAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    removeLiquidity(
      args: ICollateralPool.RemoveLiquidityArgsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setConfig(
      key: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setMarket(
      marketId: PromiseOrValue<BytesLike>,
      isLong: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    symbol(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    totalSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    transfer(
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    transferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updateMarketBorrowing(
      marketId: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
