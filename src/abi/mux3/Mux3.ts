/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../common";

export type PositionPoolReaderStruct = {
  poolAddress: PromiseOrValue<string>;
  size: PromiseOrValue<BigNumberish>;
  entryPrice: PromiseOrValue<BigNumberish>;
  entryBorrowing: PromiseOrValue<BigNumberish>;
};

export type PositionPoolReaderStructOutput = [
  string,
  BigNumber,
  BigNumber,
  BigNumber
] & {
  poolAddress: string;
  size: BigNumber;
  entryPrice: BigNumber;
  entryBorrowing: BigNumber;
};

export type PositionReaderStruct = {
  marketId: PromiseOrValue<BytesLike>;
  initialLeverage: PromiseOrValue<BigNumberish>;
  lastIncreasedTime: PromiseOrValue<BigNumberish>;
  realizedBorrowingUsd: PromiseOrValue<BigNumberish>;
  pools: PositionPoolReaderStruct[];
};

export type PositionReaderStructOutput = [
  string,
  BigNumber,
  BigNumber,
  BigNumber,
  PositionPoolReaderStructOutput[]
] & {
  marketId: string;
  initialLeverage: BigNumber;
  lastIncreasedTime: BigNumber;
  realizedBorrowingUsd: BigNumber;
  pools: PositionPoolReaderStructOutput[];
};

export type CollateralReaderStruct = {
  collateralAddress: PromiseOrValue<string>;
  collateralAmount: PromiseOrValue<BigNumberish>;
};

export type CollateralReaderStructOutput = [string, BigNumber] & {
  collateralAddress: string;
  collateralAmount: BigNumber;
};

export type AccountReaderStruct = {
  positionId: PromiseOrValue<BytesLike>;
  collaterals: CollateralReaderStruct[];
  positions: PositionReaderStruct[];
};

export type AccountReaderStructOutput = [
  string,
  CollateralReaderStructOutput[],
  PositionReaderStructOutput[]
] & {
  positionId: string;
  collaterals: CollateralReaderStructOutput[];
  positions: PositionReaderStructOutput[];
};

export type BackedPoolStateStruct = { backedPool: PromiseOrValue<string> };

export type BackedPoolStateStructOutput = [string] & { backedPool: string };

export declare namespace IFacetClose {
  export type ClosePositionArgsStruct = {
    positionId: PromiseOrValue<BytesLike>;
    marketId: PromiseOrValue<BytesLike>;
    size: PromiseOrValue<BigNumberish>;
    lastConsumedToken: PromiseOrValue<string>;
    isUnwrapWeth: PromiseOrValue<boolean>;
  };

  export type ClosePositionArgsStructOutput = [
    string,
    string,
    BigNumber,
    string,
    boolean
  ] & {
    positionId: string;
    marketId: string;
    size: BigNumber;
    lastConsumedToken: string;
    isUnwrapWeth: boolean;
  };

  export type ClosePositionResultStruct = {
    tradingPrice: PromiseOrValue<BigNumberish>;
    poolPnlUsds: PromiseOrValue<BigNumberish>[];
    borrowingFeeUsd: PromiseOrValue<BigNumberish>;
    positionFeeUsd: PromiseOrValue<BigNumberish>;
  };

  export type ClosePositionResultStructOutput = [
    BigNumber,
    BigNumber[],
    BigNumber,
    BigNumber
  ] & {
    tradingPrice: BigNumber;
    poolPnlUsds: BigNumber[];
    borrowingFeeUsd: BigNumber;
    positionFeeUsd: BigNumber;
  };

  export type LiquidateArgsStruct = {
    positionId: PromiseOrValue<BytesLike>;
    lastConsumedToken: PromiseOrValue<string>;
    isUnwrapWeth: PromiseOrValue<boolean>;
  };

  export type LiquidateArgsStructOutput = [string, string, boolean] & {
    positionId: string;
    lastConsumedToken: string;
    isUnwrapWeth: boolean;
  };

  export type LiquidatePositionResultStruct = {
    marketId: PromiseOrValue<BytesLike>;
    tradingPrice: PromiseOrValue<BigNumberish>;
    poolPnlUsds: PromiseOrValue<BigNumberish>[];
    borrowingFeeUsd: PromiseOrValue<BigNumberish>;
    positionFeeUsd: PromiseOrValue<BigNumberish>;
  };

  export type LiquidatePositionResultStructOutput = [
    string,
    BigNumber,
    BigNumber[],
    BigNumber,
    BigNumber
  ] & {
    marketId: string;
    tradingPrice: BigNumber;
    poolPnlUsds: BigNumber[];
    borrowingFeeUsd: BigNumber;
    positionFeeUsd: BigNumber;
  };

  export type LiquidateResultStruct = {
    positions: IFacetClose.LiquidatePositionResultStruct[];
  };

  export type LiquidateResultStructOutput = [
    IFacetClose.LiquidatePositionResultStructOutput[]
  ] & { positions: IFacetClose.LiquidatePositionResultStructOutput[] };
}

export declare namespace IFacetOpen {
  export type OpenPositionArgsStruct = {
    positionId: PromiseOrValue<BytesLike>;
    marketId: PromiseOrValue<BytesLike>;
    size: PromiseOrValue<BigNumberish>;
    lastConsumedToken: PromiseOrValue<string>;
    isUnwrapWeth: PromiseOrValue<boolean>;
  };

  export type OpenPositionArgsStructOutput = [
    string,
    string,
    BigNumber,
    string,
    boolean
  ] & {
    positionId: string;
    marketId: string;
    size: BigNumber;
    lastConsumedToken: string;
    isUnwrapWeth: boolean;
  };

  export type OpenPositionResultStruct = {
    tradingPrice: PromiseOrValue<BigNumberish>;
    borrowingFeeUsd: PromiseOrValue<BigNumberish>;
    positionFeeUsd: PromiseOrValue<BigNumberish>;
  };

  export type OpenPositionResultStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    tradingPrice: BigNumber;
    borrowingFeeUsd: BigNumber;
    positionFeeUsd: BigNumber;
  };

  export type ReallocatePositionArgsStruct = {
    positionId: PromiseOrValue<BytesLike>;
    marketId: PromiseOrValue<BytesLike>;
    fromPool: PromiseOrValue<string>;
    toPool: PromiseOrValue<string>;
    size: PromiseOrValue<BigNumberish>;
    lastConsumedToken: PromiseOrValue<string>;
    isUnwrapWeth: PromiseOrValue<boolean>;
  };

  export type ReallocatePositionArgsStructOutput = [
    string,
    string,
    string,
    string,
    BigNumber,
    string,
    boolean
  ] & {
    positionId: string;
    marketId: string;
    fromPool: string;
    toPool: string;
    size: BigNumber;
    lastConsumedToken: string;
    isUnwrapWeth: boolean;
  };

  export type ReallocatePositionResultStruct = {
    tradingPrice: PromiseOrValue<BigNumberish>;
    borrowingFeeUsd: PromiseOrValue<BigNumberish>;
  };

  export type ReallocatePositionResultStructOutput = [BigNumber, BigNumber] & {
    tradingPrice: BigNumber;
    borrowingFeeUsd: BigNumber;
  };
}

export declare namespace IFacetPositionAccount {
  export type WithdrawArgsStruct = {
    positionId: PromiseOrValue<BytesLike>;
    collateralToken: PromiseOrValue<string>;
    amount: PromiseOrValue<BigNumberish>;
    lastConsumedToken: PromiseOrValue<string>;
    isUnwrapWeth: PromiseOrValue<boolean>;
    withdrawSwapToken: PromiseOrValue<string>;
    withdrawSwapSlippage: PromiseOrValue<BigNumberish>;
  };

  export type WithdrawArgsStructOutput = [
    string,
    string,
    BigNumber,
    string,
    boolean,
    string,
    BigNumber
  ] & {
    positionId: string;
    collateralToken: string;
    amount: BigNumber;
    lastConsumedToken: string;
    isUnwrapWeth: boolean;
    withdrawSwapToken: string;
    withdrawSwapSlippage: BigNumber;
  };

  export type WithdrawAllArgsStruct = {
    positionId: PromiseOrValue<BytesLike>;
    isUnwrapWeth: PromiseOrValue<boolean>;
    withdrawSwapToken: PromiseOrValue<string>;
    withdrawSwapSlippage: PromiseOrValue<BigNumberish>;
  };

  export type WithdrawAllArgsStructOutput = [
    string,
    boolean,
    string,
    BigNumber
  ] & {
    positionId: string;
    isUnwrapWeth: boolean;
    withdrawSwapToken: string;
    withdrawSwapSlippage: BigNumber;
  };

  export type WithdrawUsdArgsStruct = {
    positionId: PromiseOrValue<BytesLike>;
    collateralUsd: PromiseOrValue<BigNumberish>;
    lastConsumedToken: PromiseOrValue<string>;
    isUnwrapWeth: PromiseOrValue<boolean>;
    withdrawSwapToken: PromiseOrValue<string>;
    withdrawSwapSlippage: PromiseOrValue<BigNumberish>;
  };

  export type WithdrawUsdArgsStructOutput = [
    string,
    BigNumber,
    string,
    boolean,
    string,
    BigNumber
  ] & {
    positionId: string;
    collateralUsd: BigNumber;
    lastConsumedToken: string;
    isUnwrapWeth: boolean;
    withdrawSwapToken: string;
    withdrawSwapSlippage: BigNumber;
  };
}

export interface Mux3Interface extends utils.Interface {
  functions: {
    "addCollateralToken(address,uint8,bool)": FunctionFragment;
    "appendBackedPoolsToMarket(bytes32,address[])": FunctionFragment;
    "closePosition((bytes32,bytes32,uint256,address,bool))": FunctionFragment;
    "configValue(bytes32)": FunctionFragment;
    "createCollateralPool(string,string,address,uint256)": FunctionFragment;
    "createMarket(bytes32,string,bool,address[])": FunctionFragment;
    "deposit(bytes32,address,uint256)": FunctionFragment;
    "getCollateralPool(address)": FunctionFragment;
    "getCollateralToken(address)": FunctionFragment;
    "getPositionAccount(bytes32,bytes32)": FunctionFragment;
    "getRoleMember(bytes32,uint256)": FunctionFragment;
    "getRoleMemberCount(bytes32)": FunctionFragment;
    "grantRole(bytes32,address)": FunctionFragment;
    "hasRole(bytes32,address)": FunctionFragment;
    "implementation()": FunctionFragment;
    "initialize(address)": FunctionFragment;
    "isDeleverageAllowed(bytes32,bytes32)": FunctionFragment;
    "liquidate((bytes32,address,bool))": FunctionFragment;
    "listAccountCollaterals(bytes32)": FunctionFragment;
    "listAccountPositions(bytes32)": FunctionFragment;
    "listActiveCollateralsAndPositions(uint256,uint256)": FunctionFragment;
    "listActivePositionIds(uint256,uint256)": FunctionFragment;
    "listCollateralPool()": FunctionFragment;
    "listCollateralTokens()": FunctionFragment;
    "listCollateralsAndPositionsOf(address)": FunctionFragment;
    "listMarketPools(bytes32)": FunctionFragment;
    "listMarkets()": FunctionFragment;
    "listPositionIdsOf(address)": FunctionFragment;
    "marketConfigValue(bytes32,bytes32)": FunctionFragment;
    "marketState(bytes32)": FunctionFragment;
    "openPosition((bytes32,bytes32,uint256,address,bool))": FunctionFragment;
    "priceOf(address)": FunctionFragment;
    "priceOf(bytes32)": FunctionFragment;
    "reallocatePosition((bytes32,bytes32,address,address,uint256,address,bool))": FunctionFragment;
    "revokeRole(bytes32,address)": FunctionFragment;
    "setCollateralPoolImplementation(address)": FunctionFragment;
    "setConfig(bytes32,bytes32)": FunctionFragment;
    "setInitialLeverage(bytes32,bytes32,uint256)": FunctionFragment;
    "setMarketConfig(bytes32,bytes32,bytes32)": FunctionFragment;
    "setOracleProvider(address,bool)": FunctionFragment;
    "setPoolConfig(address,bytes32,bytes32)": FunctionFragment;
    "setPrice(bytes32,address,bytes)": FunctionFragment;
    "setStrictStableId(bytes32,bool)": FunctionFragment;
    "updateBorrowingFee(bytes32,bytes32,address,bool)": FunctionFragment;
    "withdraw((bytes32,address,uint256,address,bool,address,uint256))": FunctionFragment;
    "withdrawAll((bytes32,bool,address,uint256))": FunctionFragment;
    "withdrawUsd((bytes32,uint256,address,bool,address,uint256))": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "addCollateralToken"
      | "appendBackedPoolsToMarket"
      | "closePosition"
      | "configValue"
      | "createCollateralPool"
      | "createMarket"
      | "deposit"
      | "getCollateralPool"
      | "getCollateralToken"
      | "getPositionAccount"
      | "getRoleMember"
      | "getRoleMemberCount"
      | "grantRole"
      | "hasRole"
      | "implementation"
      | "initialize"
      | "isDeleverageAllowed"
      | "liquidate"
      | "listAccountCollaterals"
      | "listAccountPositions"
      | "listActiveCollateralsAndPositions"
      | "listActivePositionIds"
      | "listCollateralPool"
      | "listCollateralTokens"
      | "listCollateralsAndPositionsOf"
      | "listMarketPools"
      | "listMarkets"
      | "listPositionIdsOf"
      | "marketConfigValue"
      | "marketState"
      | "openPosition"
      | "priceOf(address)"
      | "priceOf(bytes32)"
      | "reallocatePosition"
      | "revokeRole"
      | "setCollateralPoolImplementation"
      | "setConfig"
      | "setInitialLeverage"
      | "setMarketConfig"
      | "setOracleProvider"
      | "setPoolConfig"
      | "setPrice"
      | "setStrictStableId"
      | "updateBorrowingFee"
      | "withdraw"
      | "withdrawAll"
      | "withdrawUsd"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "addCollateralToken",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "appendBackedPoolsToMarket",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "closePosition",
    values: [IFacetClose.ClosePositionArgsStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "configValue",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "createCollateralPool",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "createMarket",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<string>,
      PromiseOrValue<boolean>,
      PromiseOrValue<string>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "deposit",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getCollateralPool",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getCollateralToken",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getPositionAccount",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "getRoleMember",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getRoleMemberCount",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "grantRole",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "hasRole",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "implementation",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "isDeleverageAllowed",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "liquidate",
    values: [IFacetClose.LiquidateArgsStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "listAccountCollaterals",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "listAccountPositions",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "listActiveCollateralsAndPositions",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "listActivePositionIds",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "listCollateralPool",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "listCollateralTokens",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "listCollateralsAndPositionsOf",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "listMarketPools",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "listMarkets",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "listPositionIdsOf",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "marketConfigValue",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "marketState",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "openPosition",
    values: [IFacetOpen.OpenPositionArgsStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "priceOf(address)",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "priceOf(bytes32)",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "reallocatePosition",
    values: [IFacetOpen.ReallocatePositionArgsStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "revokeRole",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setCollateralPoolImplementation",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setConfig",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "setInitialLeverage",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setMarketConfig",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setOracleProvider",
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "setPoolConfig",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setPrice",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setStrictStableId",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "updateBorrowingFee",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<string>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "withdraw",
    values: [IFacetPositionAccount.WithdrawArgsStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawAll",
    values: [IFacetPositionAccount.WithdrawAllArgsStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawUsd",
    values: [IFacetPositionAccount.WithdrawUsdArgsStruct]
  ): string;

  decodeFunctionResult(
    functionFragment: "addCollateralToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "appendBackedPoolsToMarket",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "closePosition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "configValue",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createCollateralPool",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createMarket",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "deposit", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getCollateralPool",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCollateralToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getPositionAccount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getRoleMember",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getRoleMemberCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "grantRole", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "hasRole", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "implementation",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isDeleverageAllowed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "liquidate", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "listAccountCollaterals",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "listAccountPositions",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "listActiveCollateralsAndPositions",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "listActivePositionIds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "listCollateralPool",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "listCollateralTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "listCollateralsAndPositionsOf",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "listMarketPools",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "listMarkets",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "listPositionIdsOf",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "marketConfigValue",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "marketState",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "openPosition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "priceOf(address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "priceOf(bytes32)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "reallocatePosition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "revokeRole", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setCollateralPoolImplementation",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setConfig", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setInitialLeverage",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setMarketConfig",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setOracleProvider",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setPoolConfig",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setPrice", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setStrictStableId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateBorrowingFee",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "withdraw", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "withdrawAll",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawUsd",
    data: BytesLike
  ): Result;

  events: {
    "AddCollateralToken(address,uint8,bool)": EventFragment;
    "AppendBackedPoolsToMarket(bytes32,address[])": EventFragment;
    "ClosePosition(address,bytes32,bytes32,bool,uint256,uint256,address[],uint256[],uint256[],uint256[],int256[],uint256,uint256,address[],uint256[])": EventFragment;
    "CollectFee(address,uint256)": EventFragment;
    "CreateCollateralPool(string,string,address,uint8,address)": EventFragment;
    "CreateMarket(bytes32,string,bool,address[])": EventFragment;
    "CreatePositionAccount(address,uint256,bytes32)": EventFragment;
    "Deposit(address,bytes32,address,uint256)": EventFragment;
    "DepositWithdrawFinish(address,bytes32,uint256,address[],uint256[])": EventFragment;
    "Initialized(uint8)": EventFragment;
    "LiquidatePosition(address,bytes32,bytes32,bool,uint256,uint256,address[],uint256[],int256[],uint256,uint256,address[],uint256[])": EventFragment;
    "OpenPosition(address,bytes32,bytes32,bool,uint256,uint256,address[],uint256[],uint256[],uint256[],uint256,uint256,address[],uint256[])": EventFragment;
    "ReallocatePosition(address,bytes32,bytes32,bool,address,address,uint256,uint256,uint256,address[],uint256[],uint256[],int256[],uint256,address[],uint256[])": EventFragment;
    "RoleGranted(bytes32,address,address)": EventFragment;
    "RoleRevoked(bytes32,address,address)": EventFragment;
    "SetCollateralPoolConfig(address,bytes32,bytes32)": EventFragment;
    "SetCollateralPoolImplementation(address)": EventFragment;
    "SetCollateralTokenEnabled(address,bool)": EventFragment;
    "SetConfig(bytes32,bytes32)": EventFragment;
    "SetInitialLeverage(address,bytes32,bytes32,uint256)": EventFragment;
    "SetMarketConfig(bytes32,bytes32,bytes32)": EventFragment;
    "SetOracleProvider(address,bool)": EventFragment;
    "SetPrice(bytes32,address,uint256,uint256)": EventFragment;
    "SetStrictStableId(bytes32,bool)": EventFragment;
    "SetValue(bytes32,bytes32)": EventFragment;
    "UpdatePositionBorrowingFee(address,bytes32,bytes32,uint256)": EventFragment;
    "Withdraw(address,bytes32,address,uint256,address,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "AddCollateralToken"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AppendBackedPoolsToMarket"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ClosePosition"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "CollectFee"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "CreateCollateralPool"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "CreateMarket"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "CreatePositionAccount"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Deposit"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "DepositWithdrawFinish"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Initialized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LiquidatePosition"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OpenPosition"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ReallocatePosition"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RoleGranted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RoleRevoked"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetCollateralPoolConfig"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "SetCollateralPoolImplementation"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetCollateralTokenEnabled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetConfig"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetInitialLeverage"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetMarketConfig"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetOracleProvider"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetPrice"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetStrictStableId"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetValue"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UpdatePositionBorrowingFee"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Withdraw"): EventFragment;
}

export interface AddCollateralTokenEventObject {
  token: string;
  decimals: number;
  isStable: boolean;
}
export type AddCollateralTokenEvent = TypedEvent<
  [string, number, boolean],
  AddCollateralTokenEventObject
>;

export type AddCollateralTokenEventFilter =
  TypedEventFilter<AddCollateralTokenEvent>;

export interface AppendBackedPoolsToMarketEventObject {
  marketId: string;
  backedPools: string[];
}
export type AppendBackedPoolsToMarketEvent = TypedEvent<
  [string, string[]],
  AppendBackedPoolsToMarketEventObject
>;

export type AppendBackedPoolsToMarketEventFilter =
  TypedEventFilter<AppendBackedPoolsToMarketEvent>;

export interface ClosePositionEventObject {
  owner: string;
  positionId: string;
  marketId: string;
  isLong: boolean;
  size: BigNumber;
  tradingPrice: BigNumber;
  backedPools: string[];
  allocations: BigNumber[];
  newSizes: BigNumber[];
  newEntryPrices: BigNumber[];
  poolPnlUsds: BigNumber[];
  positionFeeUsd: BigNumber;
  borrowingFeeUsd: BigNumber;
  newCollateralTokens: string[];
  newCollateralAmounts: BigNumber[];
}
export type ClosePositionEvent = TypedEvent<
  [
    string,
    string,
    string,
    boolean,
    BigNumber,
    BigNumber,
    string[],
    BigNumber[],
    BigNumber[],
    BigNumber[],
    BigNumber[],
    BigNumber,
    BigNumber,
    string[],
    BigNumber[]
  ],
  ClosePositionEventObject
>;

export type ClosePositionEventFilter = TypedEventFilter<ClosePositionEvent>;

export interface CollectFeeEventObject {
  feeToken: string;
  wad: BigNumber;
}
export type CollectFeeEvent = TypedEvent<
  [string, BigNumber],
  CollectFeeEventObject
>;

export type CollectFeeEventFilter = TypedEventFilter<CollectFeeEvent>;

export interface CreateCollateralPoolEventObject {
  name: string;
  symbol: string;
  collateral: string;
  collateralDecimals: number;
  pool: string;
}
export type CreateCollateralPoolEvent = TypedEvent<
  [string, string, string, number, string],
  CreateCollateralPoolEventObject
>;

export type CreateCollateralPoolEventFilter =
  TypedEventFilter<CreateCollateralPoolEvent>;

export interface CreateMarketEventObject {
  marketId: string;
  symbol: string;
  isLong: boolean;
  backedPools: string[];
}
export type CreateMarketEvent = TypedEvent<
  [string, string, boolean, string[]],
  CreateMarketEventObject
>;

export type CreateMarketEventFilter = TypedEventFilter<CreateMarketEvent>;

export interface CreatePositionAccountEventObject {
  owner: string;
  index: BigNumber;
  positionId: string;
}
export type CreatePositionAccountEvent = TypedEvent<
  [string, BigNumber, string],
  CreatePositionAccountEventObject
>;

export type CreatePositionAccountEventFilter =
  TypedEventFilter<CreatePositionAccountEvent>;

export interface DepositEventObject {
  owner: string;
  positionId: string;
  collateralToken: string;
  collateralAmount: BigNumber;
}
export type DepositEvent = TypedEvent<
  [string, string, string, BigNumber],
  DepositEventObject
>;

export type DepositEventFilter = TypedEventFilter<DepositEvent>;

export interface DepositWithdrawFinishEventObject {
  owner: string;
  positionId: string;
  borrowingFeeUsd: BigNumber;
  newCollateralTokens: string[];
  newCollateralAmounts: BigNumber[];
}
export type DepositWithdrawFinishEvent = TypedEvent<
  [string, string, BigNumber, string[], BigNumber[]],
  DepositWithdrawFinishEventObject
>;

export type DepositWithdrawFinishEventFilter =
  TypedEventFilter<DepositWithdrawFinishEvent>;

export interface InitializedEventObject {
  version: number;
}
export type InitializedEvent = TypedEvent<[number], InitializedEventObject>;

export type InitializedEventFilter = TypedEventFilter<InitializedEvent>;

export interface LiquidatePositionEventObject {
  owner: string;
  positionId: string;
  marketId: string;
  isLong: boolean;
  size: BigNumber;
  tradingPrice: BigNumber;
  backedPools: string[];
  allocations: BigNumber[];
  poolPnlUsds: BigNumber[];
  positionFeeUsd: BigNumber;
  borrowingFeeUsd: BigNumber;
  newCollateralTokens: string[];
  newCollateralAmounts: BigNumber[];
}
export type LiquidatePositionEvent = TypedEvent<
  [
    string,
    string,
    string,
    boolean,
    BigNumber,
    BigNumber,
    string[],
    BigNumber[],
    BigNumber[],
    BigNumber,
    BigNumber,
    string[],
    BigNumber[]
  ],
  LiquidatePositionEventObject
>;

export type LiquidatePositionEventFilter =
  TypedEventFilter<LiquidatePositionEvent>;

export interface OpenPositionEventObject {
  owner: string;
  positionId: string;
  marketId: string;
  isLong: boolean;
  size: BigNumber;
  tradingPrice: BigNumber;
  backedPools: string[];
  allocations: BigNumber[];
  newSizes: BigNumber[];
  newEntryPrices: BigNumber[];
  positionFeeUsd: BigNumber;
  borrowingFeeUsd: BigNumber;
  newCollateralTokens: string[];
  newCollateralAmounts: BigNumber[];
}
export type OpenPositionEvent = TypedEvent<
  [
    string,
    string,
    string,
    boolean,
    BigNumber,
    BigNumber,
    string[],
    BigNumber[],
    BigNumber[],
    BigNumber[],
    BigNumber,
    BigNumber,
    string[],
    BigNumber[]
  ],
  OpenPositionEventObject
>;

export type OpenPositionEventFilter = TypedEventFilter<OpenPositionEvent>;

export interface ReallocatePositionEventObject {
  owner: string;
  positionId: string;
  marketId: string;
  isLong: boolean;
  fromPool: string;
  toPool: string;
  size: BigNumber;
  tradingPrice: BigNumber;
  fromPoolOldEntryPrice: BigNumber;
  backedPools: string[];
  newSizes: BigNumber[];
  newEntryPrices: BigNumber[];
  poolPnlUsds: BigNumber[];
  borrowingFeeUsd: BigNumber;
  newCollateralTokens: string[];
  newCollateralAmounts: BigNumber[];
}
export type ReallocatePositionEvent = TypedEvent<
  [
    string,
    string,
    string,
    boolean,
    string,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    string[],
    BigNumber[],
    BigNumber[],
    BigNumber[],
    BigNumber,
    string[],
    BigNumber[]
  ],
  ReallocatePositionEventObject
>;

export type ReallocatePositionEventFilter =
  TypedEventFilter<ReallocatePositionEvent>;

export interface RoleGrantedEventObject {
  role: string;
  account: string;
  sender: string;
}
export type RoleGrantedEvent = TypedEvent<
  [string, string, string],
  RoleGrantedEventObject
>;

export type RoleGrantedEventFilter = TypedEventFilter<RoleGrantedEvent>;

export interface RoleRevokedEventObject {
  role: string;
  account: string;
  sender: string;
}
export type RoleRevokedEvent = TypedEvent<
  [string, string, string],
  RoleRevokedEventObject
>;

export type RoleRevokedEventFilter = TypedEventFilter<RoleRevokedEvent>;

export interface SetCollateralPoolConfigEventObject {
  pool: string;
  key: string;
  value: string;
}
export type SetCollateralPoolConfigEvent = TypedEvent<
  [string, string, string],
  SetCollateralPoolConfigEventObject
>;

export type SetCollateralPoolConfigEventFilter =
  TypedEventFilter<SetCollateralPoolConfigEvent>;

export interface SetCollateralPoolImplementationEventObject {
  newImplementation: string;
}
export type SetCollateralPoolImplementationEvent = TypedEvent<
  [string],
  SetCollateralPoolImplementationEventObject
>;

export type SetCollateralPoolImplementationEventFilter =
  TypedEventFilter<SetCollateralPoolImplementationEvent>;

export interface SetCollateralTokenEnabledEventObject {
  token: string;
  enabled: boolean;
}
export type SetCollateralTokenEnabledEvent = TypedEvent<
  [string, boolean],
  SetCollateralTokenEnabledEventObject
>;

export type SetCollateralTokenEnabledEventFilter =
  TypedEventFilter<SetCollateralTokenEnabledEvent>;

export interface SetConfigEventObject {
  key: string;
  value: string;
}
export type SetConfigEvent = TypedEvent<[string, string], SetConfigEventObject>;

export type SetConfigEventFilter = TypedEventFilter<SetConfigEvent>;

export interface SetInitialLeverageEventObject {
  owner: string;
  positionId: string;
  marketId: string;
  leverage: BigNumber;
}
export type SetInitialLeverageEvent = TypedEvent<
  [string, string, string, BigNumber],
  SetInitialLeverageEventObject
>;

export type SetInitialLeverageEventFilter =
  TypedEventFilter<SetInitialLeverageEvent>;

export interface SetMarketConfigEventObject {
  marketId: string;
  key: string;
  value: string;
}
export type SetMarketConfigEvent = TypedEvent<
  [string, string, string],
  SetMarketConfigEventObject
>;

export type SetMarketConfigEventFilter = TypedEventFilter<SetMarketConfigEvent>;

export interface SetOracleProviderEventObject {
  oracleProvider: string;
  isValid: boolean;
}
export type SetOracleProviderEvent = TypedEvent<
  [string, boolean],
  SetOracleProviderEventObject
>;

export type SetOracleProviderEventFilter =
  TypedEventFilter<SetOracleProviderEvent>;

export interface SetPriceEventObject {
  oracleId: string;
  provider: string;
  price: BigNumber;
  timestamp: BigNumber;
}
export type SetPriceEvent = TypedEvent<
  [string, string, BigNumber, BigNumber],
  SetPriceEventObject
>;

export type SetPriceEventFilter = TypedEventFilter<SetPriceEvent>;

export interface SetStrictStableIdEventObject {
  oracleId: string;
  strictStable: boolean;
}
export type SetStrictStableIdEvent = TypedEvent<
  [string, boolean],
  SetStrictStableIdEventObject
>;

export type SetStrictStableIdEventFilter =
  TypedEventFilter<SetStrictStableIdEvent>;

export interface SetValueEventObject {
  key: string;
  value: string;
}
export type SetValueEvent = TypedEvent<[string, string], SetValueEventObject>;

export type SetValueEventFilter = TypedEventFilter<SetValueEvent>;

export interface UpdatePositionBorrowingFeeEventObject {
  owner: string;
  positionId: string;
  marketId: string;
  borrowingFeeUsd: BigNumber;
}
export type UpdatePositionBorrowingFeeEvent = TypedEvent<
  [string, string, string, BigNumber],
  UpdatePositionBorrowingFeeEventObject
>;

export type UpdatePositionBorrowingFeeEventFilter =
  TypedEventFilter<UpdatePositionBorrowingFeeEvent>;

export interface WithdrawEventObject {
  owner: string;
  positionId: string;
  collateralToken: string;
  collateralWad: BigNumber;
  withdrawToken: string;
  withdrawAmount: BigNumber;
}
export type WithdrawEvent = TypedEvent<
  [string, string, string, BigNumber, string, BigNumber],
  WithdrawEventObject
>;

export type WithdrawEventFilter = TypedEventFilter<WithdrawEvent>;

export interface Mux3 extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: Mux3Interface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    addCollateralToken(
      token: PromiseOrValue<string>,
      decimals: PromiseOrValue<BigNumberish>,
      isStable: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    appendBackedPoolsToMarket(
      marketId: PromiseOrValue<BytesLike>,
      backedPools: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    closePosition(
      args: IFacetClose.ClosePositionArgsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    configValue(
      key: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[string] & { value: string }>;

    createCollateralPool(
      name: PromiseOrValue<string>,
      symbol: PromiseOrValue<string>,
      collateralToken: PromiseOrValue<string>,
      expectedPoolCount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    createMarket(
      marketId: PromiseOrValue<BytesLike>,
      symbol: PromiseOrValue<string>,
      isLong: PromiseOrValue<boolean>,
      backedPools: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    deposit(
      positionId: PromiseOrValue<BytesLike>,
      collateralToken: PromiseOrValue<string>,
      rawAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getCollateralPool(
      pool: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean] & { isExist: boolean }>;

    getCollateralToken(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [boolean, number, boolean] & {
        isExist: boolean;
        decimals: number;
        isStable: boolean;
      }
    >;

    getPositionAccount(
      positionId: PromiseOrValue<BytesLike>,
      marketId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<
      [PositionReaderStructOutput] & { position: PositionReaderStructOutput }
    >;

    getRoleMember(
      role: PromiseOrValue<BytesLike>,
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    getRoleMemberCount(
      role: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    grantRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    hasRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    implementation(overrides?: CallOverrides): Promise<[string]>;

    initialize(
      weth_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    isDeleverageAllowed(
      positionId: PromiseOrValue<BytesLike>,
      marketId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    liquidate(
      args: IFacetClose.LiquidateArgsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    listAccountCollaterals(
      positionId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<
      [CollateralReaderStructOutput[]] & {
        collaterals: CollateralReaderStructOutput[];
      }
    >;

    listAccountPositions(
      positionId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<
      [PositionReaderStructOutput[]] & {
        positions: PositionReaderStructOutput[];
      }
    >;

    listActiveCollateralsAndPositions(
      begin: PromiseOrValue<BigNumberish>,
      end: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [AccountReaderStructOutput[], BigNumber] & {
        positions: AccountReaderStructOutput[];
        totalLength: BigNumber;
      }
    >;

    listActivePositionIds(
      begin: PromiseOrValue<BigNumberish>,
      end: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [string[], BigNumber] & { positionIds: string[]; totalLength: BigNumber }
    >;

    listCollateralPool(
      overrides?: CallOverrides
    ): Promise<[string[]] & { pools: string[] }>;

    listCollateralTokens(
      overrides?: CallOverrides
    ): Promise<[string[]] & { tokens: string[] }>;

    listCollateralsAndPositionsOf(
      trader: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [AccountReaderStructOutput[]] & { positions: AccountReaderStructOutput[] }
    >;

    listMarketPools(
      marketId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<
      [BackedPoolStateStructOutput[]] & { pools: BackedPoolStateStructOutput[] }
    >;

    listMarkets(
      overrides?: CallOverrides
    ): Promise<[string[]] & { marketIds: string[] }>;

    listPositionIdsOf(
      trader: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string[]] & { positionIds: string[] }>;

    marketConfigValue(
      marketId: PromiseOrValue<BytesLike>,
      key: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[string] & { value: string }>;

    marketState(
      marketId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[string, boolean] & { symbol: string; isLong: boolean }>;

    openPosition(
      args: IFacetOpen.OpenPositionArgsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    "priceOf(address)"(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { price: BigNumber }>;

    "priceOf(bytes32)"(
      oracleId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { price: BigNumber }>;

    reallocatePosition(
      args: IFacetOpen.ReallocatePositionArgsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    revokeRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setCollateralPoolImplementation(
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setConfig(
      key: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setInitialLeverage(
      positionId: PromiseOrValue<BytesLike>,
      marketId: PromiseOrValue<BytesLike>,
      leverage: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setMarketConfig(
      marketId: PromiseOrValue<BytesLike>,
      key: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setOracleProvider(
      oracleProvider: PromiseOrValue<string>,
      isValid: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setPoolConfig(
      pool: PromiseOrValue<string>,
      key: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setPrice(
      oracleId: PromiseOrValue<BytesLike>,
      provider: PromiseOrValue<string>,
      oracleCalldata: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setStrictStableId(
      oracleId: PromiseOrValue<BytesLike>,
      strictStable: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updateBorrowingFee(
      positionId: PromiseOrValue<BytesLike>,
      marketId: PromiseOrValue<BytesLike>,
      lastConsumedToken: PromiseOrValue<string>,
      isUnwrapWeth: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    withdraw(
      args: IFacetPositionAccount.WithdrawArgsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    withdrawAll(
      args: IFacetPositionAccount.WithdrawAllArgsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    withdrawUsd(
      args: IFacetPositionAccount.WithdrawUsdArgsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  addCollateralToken(
    token: PromiseOrValue<string>,
    decimals: PromiseOrValue<BigNumberish>,
    isStable: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  appendBackedPoolsToMarket(
    marketId: PromiseOrValue<BytesLike>,
    backedPools: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  closePosition(
    args: IFacetClose.ClosePositionArgsStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  configValue(
    key: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<string>;

  createCollateralPool(
    name: PromiseOrValue<string>,
    symbol: PromiseOrValue<string>,
    collateralToken: PromiseOrValue<string>,
    expectedPoolCount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  createMarket(
    marketId: PromiseOrValue<BytesLike>,
    symbol: PromiseOrValue<string>,
    isLong: PromiseOrValue<boolean>,
    backedPools: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  deposit(
    positionId: PromiseOrValue<BytesLike>,
    collateralToken: PromiseOrValue<string>,
    rawAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getCollateralPool(
    pool: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  getCollateralToken(
    token: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<
    [boolean, number, boolean] & {
      isExist: boolean;
      decimals: number;
      isStable: boolean;
    }
  >;

  getPositionAccount(
    positionId: PromiseOrValue<BytesLike>,
    marketId: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<PositionReaderStructOutput>;

  getRoleMember(
    role: PromiseOrValue<BytesLike>,
    index: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  getRoleMemberCount(
    role: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  grantRole(
    role: PromiseOrValue<BytesLike>,
    account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  hasRole(
    role: PromiseOrValue<BytesLike>,
    account: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  implementation(overrides?: CallOverrides): Promise<string>;

  initialize(
    weth_: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  isDeleverageAllowed(
    positionId: PromiseOrValue<BytesLike>,
    marketId: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  liquidate(
    args: IFacetClose.LiquidateArgsStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  listAccountCollaterals(
    positionId: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<CollateralReaderStructOutput[]>;

  listAccountPositions(
    positionId: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<PositionReaderStructOutput[]>;

  listActiveCollateralsAndPositions(
    begin: PromiseOrValue<BigNumberish>,
    end: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [AccountReaderStructOutput[], BigNumber] & {
      positions: AccountReaderStructOutput[];
      totalLength: BigNumber;
    }
  >;

  listActivePositionIds(
    begin: PromiseOrValue<BigNumberish>,
    end: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [string[], BigNumber] & { positionIds: string[]; totalLength: BigNumber }
  >;

  listCollateralPool(overrides?: CallOverrides): Promise<string[]>;

  listCollateralTokens(overrides?: CallOverrides): Promise<string[]>;

  listCollateralsAndPositionsOf(
    trader: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<AccountReaderStructOutput[]>;

  listMarketPools(
    marketId: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BackedPoolStateStructOutput[]>;

  listMarkets(overrides?: CallOverrides): Promise<string[]>;

  listPositionIdsOf(
    trader: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<string[]>;

  marketConfigValue(
    marketId: PromiseOrValue<BytesLike>,
    key: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<string>;

  marketState(
    marketId: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<[string, boolean] & { symbol: string; isLong: boolean }>;

  openPosition(
    args: IFacetOpen.OpenPositionArgsStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  "priceOf(address)"(
    token: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "priceOf(bytes32)"(
    oracleId: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  reallocatePosition(
    args: IFacetOpen.ReallocatePositionArgsStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  revokeRole(
    role: PromiseOrValue<BytesLike>,
    account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setCollateralPoolImplementation(
    newImplementation: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setConfig(
    key: PromiseOrValue<BytesLike>,
    value: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setInitialLeverage(
    positionId: PromiseOrValue<BytesLike>,
    marketId: PromiseOrValue<BytesLike>,
    leverage: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setMarketConfig(
    marketId: PromiseOrValue<BytesLike>,
    key: PromiseOrValue<BytesLike>,
    value: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setOracleProvider(
    oracleProvider: PromiseOrValue<string>,
    isValid: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setPoolConfig(
    pool: PromiseOrValue<string>,
    key: PromiseOrValue<BytesLike>,
    value: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setPrice(
    oracleId: PromiseOrValue<BytesLike>,
    provider: PromiseOrValue<string>,
    oracleCalldata: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setStrictStableId(
    oracleId: PromiseOrValue<BytesLike>,
    strictStable: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updateBorrowingFee(
    positionId: PromiseOrValue<BytesLike>,
    marketId: PromiseOrValue<BytesLike>,
    lastConsumedToken: PromiseOrValue<string>,
    isUnwrapWeth: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  withdraw(
    args: IFacetPositionAccount.WithdrawArgsStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  withdrawAll(
    args: IFacetPositionAccount.WithdrawAllArgsStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  withdrawUsd(
    args: IFacetPositionAccount.WithdrawUsdArgsStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    addCollateralToken(
      token: PromiseOrValue<string>,
      decimals: PromiseOrValue<BigNumberish>,
      isStable: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    appendBackedPoolsToMarket(
      marketId: PromiseOrValue<BytesLike>,
      backedPools: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<void>;

    closePosition(
      args: IFacetClose.ClosePositionArgsStruct,
      overrides?: CallOverrides
    ): Promise<IFacetClose.ClosePositionResultStructOutput>;

    configValue(
      key: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    createCollateralPool(
      name: PromiseOrValue<string>,
      symbol: PromiseOrValue<string>,
      collateralToken: PromiseOrValue<string>,
      expectedPoolCount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    createMarket(
      marketId: PromiseOrValue<BytesLike>,
      symbol: PromiseOrValue<string>,
      isLong: PromiseOrValue<boolean>,
      backedPools: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<void>;

    deposit(
      positionId: PromiseOrValue<BytesLike>,
      collateralToken: PromiseOrValue<string>,
      rawAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    getCollateralPool(
      pool: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    getCollateralToken(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [boolean, number, boolean] & {
        isExist: boolean;
        decimals: number;
        isStable: boolean;
      }
    >;

    getPositionAccount(
      positionId: PromiseOrValue<BytesLike>,
      marketId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PositionReaderStructOutput>;

    getRoleMember(
      role: PromiseOrValue<BytesLike>,
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    getRoleMemberCount(
      role: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    grantRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    hasRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    implementation(overrides?: CallOverrides): Promise<string>;

    initialize(
      weth_: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    isDeleverageAllowed(
      positionId: PromiseOrValue<BytesLike>,
      marketId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    liquidate(
      args: IFacetClose.LiquidateArgsStruct,
      overrides?: CallOverrides
    ): Promise<IFacetClose.LiquidateResultStructOutput>;

    listAccountCollaterals(
      positionId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<CollateralReaderStructOutput[]>;

    listAccountPositions(
      positionId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PositionReaderStructOutput[]>;

    listActiveCollateralsAndPositions(
      begin: PromiseOrValue<BigNumberish>,
      end: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [AccountReaderStructOutput[], BigNumber] & {
        positions: AccountReaderStructOutput[];
        totalLength: BigNumber;
      }
    >;

    listActivePositionIds(
      begin: PromiseOrValue<BigNumberish>,
      end: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [string[], BigNumber] & { positionIds: string[]; totalLength: BigNumber }
    >;

    listCollateralPool(overrides?: CallOverrides): Promise<string[]>;

    listCollateralTokens(overrides?: CallOverrides): Promise<string[]>;

    listCollateralsAndPositionsOf(
      trader: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<AccountReaderStructOutput[]>;

    listMarketPools(
      marketId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BackedPoolStateStructOutput[]>;

    listMarkets(overrides?: CallOverrides): Promise<string[]>;

    listPositionIdsOf(
      trader: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<string[]>;

    marketConfigValue(
      marketId: PromiseOrValue<BytesLike>,
      key: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    marketState(
      marketId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[string, boolean] & { symbol: string; isLong: boolean }>;

    openPosition(
      args: IFacetOpen.OpenPositionArgsStruct,
      overrides?: CallOverrides
    ): Promise<IFacetOpen.OpenPositionResultStructOutput>;

    "priceOf(address)"(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "priceOf(bytes32)"(
      oracleId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    reallocatePosition(
      args: IFacetOpen.ReallocatePositionArgsStruct,
      overrides?: CallOverrides
    ): Promise<IFacetOpen.ReallocatePositionResultStructOutput>;

    revokeRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setCollateralPoolImplementation(
      newImplementation: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setConfig(
      key: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    setInitialLeverage(
      positionId: PromiseOrValue<BytesLike>,
      marketId: PromiseOrValue<BytesLike>,
      leverage: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setMarketConfig(
      marketId: PromiseOrValue<BytesLike>,
      key: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    setOracleProvider(
      oracleProvider: PromiseOrValue<string>,
      isValid: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    setPoolConfig(
      pool: PromiseOrValue<string>,
      key: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    setPrice(
      oracleId: PromiseOrValue<BytesLike>,
      provider: PromiseOrValue<string>,
      oracleCalldata: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    setStrictStableId(
      oracleId: PromiseOrValue<BytesLike>,
      strictStable: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    updateBorrowingFee(
      positionId: PromiseOrValue<BytesLike>,
      marketId: PromiseOrValue<BytesLike>,
      lastConsumedToken: PromiseOrValue<string>,
      isUnwrapWeth: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    withdraw(
      args: IFacetPositionAccount.WithdrawArgsStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    withdrawAll(
      args: IFacetPositionAccount.WithdrawAllArgsStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    withdrawUsd(
      args: IFacetPositionAccount.WithdrawUsdArgsStruct,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "AddCollateralToken(address,uint8,bool)"(
      token?: null,
      decimals?: null,
      isStable?: null
    ): AddCollateralTokenEventFilter;
    AddCollateralToken(
      token?: null,
      decimals?: null,
      isStable?: null
    ): AddCollateralTokenEventFilter;

    "AppendBackedPoolsToMarket(bytes32,address[])"(
      marketId?: null,
      backedPools?: null
    ): AppendBackedPoolsToMarketEventFilter;
    AppendBackedPoolsToMarket(
      marketId?: null,
      backedPools?: null
    ): AppendBackedPoolsToMarketEventFilter;

    "ClosePosition(address,bytes32,bytes32,bool,uint256,uint256,address[],uint256[],uint256[],uint256[],int256[],uint256,uint256,address[],uint256[])"(
      owner?: PromiseOrValue<string> | null,
      positionId?: PromiseOrValue<BytesLike> | null,
      marketId?: PromiseOrValue<BytesLike> | null,
      isLong?: null,
      size?: null,
      tradingPrice?: null,
      backedPools?: null,
      allocations?: null,
      newSizes?: null,
      newEntryPrices?: null,
      poolPnlUsds?: null,
      positionFeeUsd?: null,
      borrowingFeeUsd?: null,
      newCollateralTokens?: null,
      newCollateralAmounts?: null
    ): ClosePositionEventFilter;
    ClosePosition(
      owner?: PromiseOrValue<string> | null,
      positionId?: PromiseOrValue<BytesLike> | null,
      marketId?: PromiseOrValue<BytesLike> | null,
      isLong?: null,
      size?: null,
      tradingPrice?: null,
      backedPools?: null,
      allocations?: null,
      newSizes?: null,
      newEntryPrices?: null,
      poolPnlUsds?: null,
      positionFeeUsd?: null,
      borrowingFeeUsd?: null,
      newCollateralTokens?: null,
      newCollateralAmounts?: null
    ): ClosePositionEventFilter;

    "CollectFee(address,uint256)"(
      feeToken?: null,
      wad?: null
    ): CollectFeeEventFilter;
    CollectFee(feeToken?: null, wad?: null): CollectFeeEventFilter;

    "CreateCollateralPool(string,string,address,uint8,address)"(
      name?: null,
      symbol?: null,
      collateral?: null,
      collateralDecimals?: null,
      pool?: null
    ): CreateCollateralPoolEventFilter;
    CreateCollateralPool(
      name?: null,
      symbol?: null,
      collateral?: null,
      collateralDecimals?: null,
      pool?: null
    ): CreateCollateralPoolEventFilter;

    "CreateMarket(bytes32,string,bool,address[])"(
      marketId?: null,
      symbol?: null,
      isLong?: null,
      backedPools?: null
    ): CreateMarketEventFilter;
    CreateMarket(
      marketId?: null,
      symbol?: null,
      isLong?: null,
      backedPools?: null
    ): CreateMarketEventFilter;

    "CreatePositionAccount(address,uint256,bytes32)"(
      owner?: PromiseOrValue<string> | null,
      index?: null,
      positionId?: PromiseOrValue<BytesLike> | null
    ): CreatePositionAccountEventFilter;
    CreatePositionAccount(
      owner?: PromiseOrValue<string> | null,
      index?: null,
      positionId?: PromiseOrValue<BytesLike> | null
    ): CreatePositionAccountEventFilter;

    "Deposit(address,bytes32,address,uint256)"(
      owner?: PromiseOrValue<string> | null,
      positionId?: PromiseOrValue<BytesLike> | null,
      collateralToken?: null,
      collateralAmount?: null
    ): DepositEventFilter;
    Deposit(
      owner?: PromiseOrValue<string> | null,
      positionId?: PromiseOrValue<BytesLike> | null,
      collateralToken?: null,
      collateralAmount?: null
    ): DepositEventFilter;

    "DepositWithdrawFinish(address,bytes32,uint256,address[],uint256[])"(
      owner?: PromiseOrValue<string> | null,
      positionId?: PromiseOrValue<BytesLike> | null,
      borrowingFeeUsd?: null,
      newCollateralTokens?: null,
      newCollateralAmounts?: null
    ): DepositWithdrawFinishEventFilter;
    DepositWithdrawFinish(
      owner?: PromiseOrValue<string> | null,
      positionId?: PromiseOrValue<BytesLike> | null,
      borrowingFeeUsd?: null,
      newCollateralTokens?: null,
      newCollateralAmounts?: null
    ): DepositWithdrawFinishEventFilter;

    "Initialized(uint8)"(version?: null): InitializedEventFilter;
    Initialized(version?: null): InitializedEventFilter;

    "LiquidatePosition(address,bytes32,bytes32,bool,uint256,uint256,address[],uint256[],int256[],uint256,uint256,address[],uint256[])"(
      owner?: PromiseOrValue<string> | null,
      positionId?: PromiseOrValue<BytesLike> | null,
      marketId?: PromiseOrValue<BytesLike> | null,
      isLong?: null,
      size?: null,
      tradingPrice?: null,
      backedPools?: null,
      allocations?: null,
      poolPnlUsds?: null,
      positionFeeUsd?: null,
      borrowingFeeUsd?: null,
      newCollateralTokens?: null,
      newCollateralAmounts?: null
    ): LiquidatePositionEventFilter;
    LiquidatePosition(
      owner?: PromiseOrValue<string> | null,
      positionId?: PromiseOrValue<BytesLike> | null,
      marketId?: PromiseOrValue<BytesLike> | null,
      isLong?: null,
      size?: null,
      tradingPrice?: null,
      backedPools?: null,
      allocations?: null,
      poolPnlUsds?: null,
      positionFeeUsd?: null,
      borrowingFeeUsd?: null,
      newCollateralTokens?: null,
      newCollateralAmounts?: null
    ): LiquidatePositionEventFilter;

    "OpenPosition(address,bytes32,bytes32,bool,uint256,uint256,address[],uint256[],uint256[],uint256[],uint256,uint256,address[],uint256[])"(
      owner?: PromiseOrValue<string> | null,
      positionId?: PromiseOrValue<BytesLike> | null,
      marketId?: PromiseOrValue<BytesLike> | null,
      isLong?: null,
      size?: null,
      tradingPrice?: null,
      backedPools?: null,
      allocations?: null,
      newSizes?: null,
      newEntryPrices?: null,
      positionFeeUsd?: null,
      borrowingFeeUsd?: null,
      newCollateralTokens?: null,
      newCollateralAmounts?: null
    ): OpenPositionEventFilter;
    OpenPosition(
      owner?: PromiseOrValue<string> | null,
      positionId?: PromiseOrValue<BytesLike> | null,
      marketId?: PromiseOrValue<BytesLike> | null,
      isLong?: null,
      size?: null,
      tradingPrice?: null,
      backedPools?: null,
      allocations?: null,
      newSizes?: null,
      newEntryPrices?: null,
      positionFeeUsd?: null,
      borrowingFeeUsd?: null,
      newCollateralTokens?: null,
      newCollateralAmounts?: null
    ): OpenPositionEventFilter;

    "ReallocatePosition(address,bytes32,bytes32,bool,address,address,uint256,uint256,uint256,address[],uint256[],uint256[],int256[],uint256,address[],uint256[])"(
      owner?: PromiseOrValue<string> | null,
      positionId?: PromiseOrValue<BytesLike> | null,
      marketId?: PromiseOrValue<BytesLike> | null,
      isLong?: null,
      fromPool?: null,
      toPool?: null,
      size?: null,
      tradingPrice?: null,
      fromPoolOldEntryPrice?: null,
      backedPools?: null,
      newSizes?: null,
      newEntryPrices?: null,
      poolPnlUsds?: null,
      borrowingFeeUsd?: null,
      newCollateralTokens?: null,
      newCollateralAmounts?: null
    ): ReallocatePositionEventFilter;
    ReallocatePosition(
      owner?: PromiseOrValue<string> | null,
      positionId?: PromiseOrValue<BytesLike> | null,
      marketId?: PromiseOrValue<BytesLike> | null,
      isLong?: null,
      fromPool?: null,
      toPool?: null,
      size?: null,
      tradingPrice?: null,
      fromPoolOldEntryPrice?: null,
      backedPools?: null,
      newSizes?: null,
      newEntryPrices?: null,
      poolPnlUsds?: null,
      borrowingFeeUsd?: null,
      newCollateralTokens?: null,
      newCollateralAmounts?: null
    ): ReallocatePositionEventFilter;

    "RoleGranted(bytes32,address,address)"(
      role?: PromiseOrValue<BytesLike> | null,
      account?: PromiseOrValue<string> | null,
      sender?: PromiseOrValue<string> | null
    ): RoleGrantedEventFilter;
    RoleGranted(
      role?: PromiseOrValue<BytesLike> | null,
      account?: PromiseOrValue<string> | null,
      sender?: PromiseOrValue<string> | null
    ): RoleGrantedEventFilter;

    "RoleRevoked(bytes32,address,address)"(
      role?: PromiseOrValue<BytesLike> | null,
      account?: PromiseOrValue<string> | null,
      sender?: PromiseOrValue<string> | null
    ): RoleRevokedEventFilter;
    RoleRevoked(
      role?: PromiseOrValue<BytesLike> | null,
      account?: PromiseOrValue<string> | null,
      sender?: PromiseOrValue<string> | null
    ): RoleRevokedEventFilter;

    "SetCollateralPoolConfig(address,bytes32,bytes32)"(
      pool?: null,
      key?: null,
      value?: null
    ): SetCollateralPoolConfigEventFilter;
    SetCollateralPoolConfig(
      pool?: null,
      key?: null,
      value?: null
    ): SetCollateralPoolConfigEventFilter;

    "SetCollateralPoolImplementation(address)"(
      newImplementation?: null
    ): SetCollateralPoolImplementationEventFilter;
    SetCollateralPoolImplementation(
      newImplementation?: null
    ): SetCollateralPoolImplementationEventFilter;

    "SetCollateralTokenEnabled(address,bool)"(
      token?: null,
      enabled?: null
    ): SetCollateralTokenEnabledEventFilter;
    SetCollateralTokenEnabled(
      token?: null,
      enabled?: null
    ): SetCollateralTokenEnabledEventFilter;

    "SetConfig(bytes32,bytes32)"(
      key?: null,
      value?: null
    ): SetConfigEventFilter;
    SetConfig(key?: null, value?: null): SetConfigEventFilter;

    "SetInitialLeverage(address,bytes32,bytes32,uint256)"(
      owner?: PromiseOrValue<string> | null,
      positionId?: PromiseOrValue<BytesLike> | null,
      marketId?: null,
      leverage?: null
    ): SetInitialLeverageEventFilter;
    SetInitialLeverage(
      owner?: PromiseOrValue<string> | null,
      positionId?: PromiseOrValue<BytesLike> | null,
      marketId?: null,
      leverage?: null
    ): SetInitialLeverageEventFilter;

    "SetMarketConfig(bytes32,bytes32,bytes32)"(
      marketId?: null,
      key?: null,
      value?: null
    ): SetMarketConfigEventFilter;
    SetMarketConfig(
      marketId?: null,
      key?: null,
      value?: null
    ): SetMarketConfigEventFilter;

    "SetOracleProvider(address,bool)"(
      oracleProvider?: null,
      isValid?: null
    ): SetOracleProviderEventFilter;
    SetOracleProvider(
      oracleProvider?: null,
      isValid?: null
    ): SetOracleProviderEventFilter;

    "SetPrice(bytes32,address,uint256,uint256)"(
      oracleId?: null,
      provider?: null,
      price?: null,
      timestamp?: null
    ): SetPriceEventFilter;
    SetPrice(
      oracleId?: null,
      provider?: null,
      price?: null,
      timestamp?: null
    ): SetPriceEventFilter;

    "SetStrictStableId(bytes32,bool)"(
      oracleId?: null,
      strictStable?: null
    ): SetStrictStableIdEventFilter;
    SetStrictStableId(
      oracleId?: null,
      strictStable?: null
    ): SetStrictStableIdEventFilter;

    "SetValue(bytes32,bytes32)"(key?: null, value?: null): SetValueEventFilter;
    SetValue(key?: null, value?: null): SetValueEventFilter;

    "UpdatePositionBorrowingFee(address,bytes32,bytes32,uint256)"(
      owner?: PromiseOrValue<string> | null,
      positionId?: PromiseOrValue<BytesLike> | null,
      marketId?: PromiseOrValue<BytesLike> | null,
      borrowingFeeUsd?: null
    ): UpdatePositionBorrowingFeeEventFilter;
    UpdatePositionBorrowingFee(
      owner?: PromiseOrValue<string> | null,
      positionId?: PromiseOrValue<BytesLike> | null,
      marketId?: PromiseOrValue<BytesLike> | null,
      borrowingFeeUsd?: null
    ): UpdatePositionBorrowingFeeEventFilter;

    "Withdraw(address,bytes32,address,uint256,address,uint256)"(
      owner?: PromiseOrValue<string> | null,
      positionId?: PromiseOrValue<BytesLike> | null,
      collateralToken?: null,
      collateralWad?: null,
      withdrawToken?: null,
      withdrawAmount?: null
    ): WithdrawEventFilter;
    Withdraw(
      owner?: PromiseOrValue<string> | null,
      positionId?: PromiseOrValue<BytesLike> | null,
      collateralToken?: null,
      collateralWad?: null,
      withdrawToken?: null,
      withdrawAmount?: null
    ): WithdrawEventFilter;
  };

  estimateGas: {
    addCollateralToken(
      token: PromiseOrValue<string>,
      decimals: PromiseOrValue<BigNumberish>,
      isStable: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    appendBackedPoolsToMarket(
      marketId: PromiseOrValue<BytesLike>,
      backedPools: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    closePosition(
      args: IFacetClose.ClosePositionArgsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    configValue(
      key: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    createCollateralPool(
      name: PromiseOrValue<string>,
      symbol: PromiseOrValue<string>,
      collateralToken: PromiseOrValue<string>,
      expectedPoolCount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    createMarket(
      marketId: PromiseOrValue<BytesLike>,
      symbol: PromiseOrValue<string>,
      isLong: PromiseOrValue<boolean>,
      backedPools: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    deposit(
      positionId: PromiseOrValue<BytesLike>,
      collateralToken: PromiseOrValue<string>,
      rawAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getCollateralPool(
      pool: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getCollateralToken(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getPositionAccount(
      positionId: PromiseOrValue<BytesLike>,
      marketId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getRoleMember(
      role: PromiseOrValue<BytesLike>,
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getRoleMemberCount(
      role: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    grantRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    hasRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    implementation(overrides?: CallOverrides): Promise<BigNumber>;

    initialize(
      weth_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    isDeleverageAllowed(
      positionId: PromiseOrValue<BytesLike>,
      marketId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    liquidate(
      args: IFacetClose.LiquidateArgsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    listAccountCollaterals(
      positionId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    listAccountPositions(
      positionId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    listActiveCollateralsAndPositions(
      begin: PromiseOrValue<BigNumberish>,
      end: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    listActivePositionIds(
      begin: PromiseOrValue<BigNumberish>,
      end: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    listCollateralPool(overrides?: CallOverrides): Promise<BigNumber>;

    listCollateralTokens(overrides?: CallOverrides): Promise<BigNumber>;

    listCollateralsAndPositionsOf(
      trader: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    listMarketPools(
      marketId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    listMarkets(overrides?: CallOverrides): Promise<BigNumber>;

    listPositionIdsOf(
      trader: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    marketConfigValue(
      marketId: PromiseOrValue<BytesLike>,
      key: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    marketState(
      marketId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    openPosition(
      args: IFacetOpen.OpenPositionArgsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    "priceOf(address)"(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "priceOf(bytes32)"(
      oracleId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    reallocatePosition(
      args: IFacetOpen.ReallocatePositionArgsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    revokeRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setCollateralPoolImplementation(
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setConfig(
      key: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setInitialLeverage(
      positionId: PromiseOrValue<BytesLike>,
      marketId: PromiseOrValue<BytesLike>,
      leverage: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setMarketConfig(
      marketId: PromiseOrValue<BytesLike>,
      key: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setOracleProvider(
      oracleProvider: PromiseOrValue<string>,
      isValid: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setPoolConfig(
      pool: PromiseOrValue<string>,
      key: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setPrice(
      oracleId: PromiseOrValue<BytesLike>,
      provider: PromiseOrValue<string>,
      oracleCalldata: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setStrictStableId(
      oracleId: PromiseOrValue<BytesLike>,
      strictStable: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updateBorrowingFee(
      positionId: PromiseOrValue<BytesLike>,
      marketId: PromiseOrValue<BytesLike>,
      lastConsumedToken: PromiseOrValue<string>,
      isUnwrapWeth: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    withdraw(
      args: IFacetPositionAccount.WithdrawArgsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    withdrawAll(
      args: IFacetPositionAccount.WithdrawAllArgsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    withdrawUsd(
      args: IFacetPositionAccount.WithdrawUsdArgsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    addCollateralToken(
      token: PromiseOrValue<string>,
      decimals: PromiseOrValue<BigNumberish>,
      isStable: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    appendBackedPoolsToMarket(
      marketId: PromiseOrValue<BytesLike>,
      backedPools: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    closePosition(
      args: IFacetClose.ClosePositionArgsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    configValue(
      key: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    createCollateralPool(
      name: PromiseOrValue<string>,
      symbol: PromiseOrValue<string>,
      collateralToken: PromiseOrValue<string>,
      expectedPoolCount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    createMarket(
      marketId: PromiseOrValue<BytesLike>,
      symbol: PromiseOrValue<string>,
      isLong: PromiseOrValue<boolean>,
      backedPools: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    deposit(
      positionId: PromiseOrValue<BytesLike>,
      collateralToken: PromiseOrValue<string>,
      rawAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getCollateralPool(
      pool: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getCollateralToken(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getPositionAccount(
      positionId: PromiseOrValue<BytesLike>,
      marketId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getRoleMember(
      role: PromiseOrValue<BytesLike>,
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getRoleMemberCount(
      role: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    grantRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    hasRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    implementation(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    initialize(
      weth_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    isDeleverageAllowed(
      positionId: PromiseOrValue<BytesLike>,
      marketId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    liquidate(
      args: IFacetClose.LiquidateArgsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    listAccountCollaterals(
      positionId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    listAccountPositions(
      positionId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    listActiveCollateralsAndPositions(
      begin: PromiseOrValue<BigNumberish>,
      end: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    listActivePositionIds(
      begin: PromiseOrValue<BigNumberish>,
      end: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    listCollateralPool(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    listCollateralTokens(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    listCollateralsAndPositionsOf(
      trader: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    listMarketPools(
      marketId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    listMarkets(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    listPositionIdsOf(
      trader: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    marketConfigValue(
      marketId: PromiseOrValue<BytesLike>,
      key: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    marketState(
      marketId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    openPosition(
      args: IFacetOpen.OpenPositionArgsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    "priceOf(address)"(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "priceOf(bytes32)"(
      oracleId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    reallocatePosition(
      args: IFacetOpen.ReallocatePositionArgsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    revokeRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setCollateralPoolImplementation(
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setConfig(
      key: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setInitialLeverage(
      positionId: PromiseOrValue<BytesLike>,
      marketId: PromiseOrValue<BytesLike>,
      leverage: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setMarketConfig(
      marketId: PromiseOrValue<BytesLike>,
      key: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setOracleProvider(
      oracleProvider: PromiseOrValue<string>,
      isValid: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setPoolConfig(
      pool: PromiseOrValue<string>,
      key: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setPrice(
      oracleId: PromiseOrValue<BytesLike>,
      provider: PromiseOrValue<string>,
      oracleCalldata: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setStrictStableId(
      oracleId: PromiseOrValue<BytesLike>,
      strictStable: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updateBorrowingFee(
      positionId: PromiseOrValue<BytesLike>,
      marketId: PromiseOrValue<BytesLike>,
      lastConsumedToken: PromiseOrValue<string>,
      isUnwrapWeth: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    withdraw(
      args: IFacetPositionAccount.WithdrawArgsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    withdrawAll(
      args: IFacetPositionAccount.WithdrawAllArgsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    withdrawUsd(
      args: IFacetPositionAccount.WithdrawUsdArgsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
