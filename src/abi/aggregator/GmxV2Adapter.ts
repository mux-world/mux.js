/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../common";

export declare namespace IOrder {
  export type AddressesStruct = {
    account: PromiseOrValue<string>;
    receiver: PromiseOrValue<string>;
    callbackContract: PromiseOrValue<string>;
    uiFeeReceiver: PromiseOrValue<string>;
    market: PromiseOrValue<string>;
    initialCollateralToken: PromiseOrValue<string>;
    swapPath: PromiseOrValue<string>[];
  };

  export type AddressesStructOutput = [
    string,
    string,
    string,
    string,
    string,
    string,
    string[]
  ] & {
    account: string;
    receiver: string;
    callbackContract: string;
    uiFeeReceiver: string;
    market: string;
    initialCollateralToken: string;
    swapPath: string[];
  };

  export type NumbersStruct = {
    orderType: PromiseOrValue<BigNumberish>;
    decreasePositionSwapType: PromiseOrValue<BigNumberish>;
    sizeDeltaUsd: PromiseOrValue<BigNumberish>;
    initialCollateralDeltaAmount: PromiseOrValue<BigNumberish>;
    triggerPrice: PromiseOrValue<BigNumberish>;
    acceptablePrice: PromiseOrValue<BigNumberish>;
    executionFee: PromiseOrValue<BigNumberish>;
    callbackGasLimit: PromiseOrValue<BigNumberish>;
    minOutputAmount: PromiseOrValue<BigNumberish>;
    updatedAtBlock: PromiseOrValue<BigNumberish>;
  };

  export type NumbersStructOutput = [
    number,
    number,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    orderType: number;
    decreasePositionSwapType: number;
    sizeDeltaUsd: BigNumber;
    initialCollateralDeltaAmount: BigNumber;
    triggerPrice: BigNumber;
    acceptablePrice: BigNumber;
    executionFee: BigNumber;
    callbackGasLimit: BigNumber;
    minOutputAmount: BigNumber;
    updatedAtBlock: BigNumber;
  };

  export type FlagsStruct = {
    isLong: PromiseOrValue<boolean>;
    shouldUnwrapNativeToken: PromiseOrValue<boolean>;
    isFrozen: PromiseOrValue<boolean>;
  };

  export type FlagsStructOutput = [boolean, boolean, boolean] & {
    isLong: boolean;
    shouldUnwrapNativeToken: boolean;
    isFrozen: boolean;
  };

  export type PropsStruct = {
    addresses: IOrder.AddressesStruct;
    numbers: IOrder.NumbersStruct;
    flags: IOrder.FlagsStruct;
  };

  export type PropsStructOutput = [
    IOrder.AddressesStructOutput,
    IOrder.NumbersStructOutput,
    IOrder.FlagsStructOutput
  ] & {
    addresses: IOrder.AddressesStructOutput;
    numbers: IOrder.NumbersStructOutput;
    flags: IOrder.FlagsStructOutput;
  };
}

export declare namespace IEvent {
  export type AddressKeyValueStruct = {
    key: PromiseOrValue<string>;
    value: PromiseOrValue<string>;
  };

  export type AddressKeyValueStructOutput = [string, string] & {
    key: string;
    value: string;
  };

  export type AddressArrayKeyValueStruct = {
    key: PromiseOrValue<string>;
    value: PromiseOrValue<string>[];
  };

  export type AddressArrayKeyValueStructOutput = [string, string[]] & {
    key: string;
    value: string[];
  };

  export type AddressItemsStruct = {
    items: IEvent.AddressKeyValueStruct[];
    arrayItems: IEvent.AddressArrayKeyValueStruct[];
  };

  export type AddressItemsStructOutput = [
    IEvent.AddressKeyValueStructOutput[],
    IEvent.AddressArrayKeyValueStructOutput[]
  ] & {
    items: IEvent.AddressKeyValueStructOutput[];
    arrayItems: IEvent.AddressArrayKeyValueStructOutput[];
  };

  export type UintKeyValueStruct = {
    key: PromiseOrValue<string>;
    value: PromiseOrValue<BigNumberish>;
  };

  export type UintKeyValueStructOutput = [string, BigNumber] & {
    key: string;
    value: BigNumber;
  };

  export type UintArrayKeyValueStruct = {
    key: PromiseOrValue<string>;
    value: PromiseOrValue<BigNumberish>[];
  };

  export type UintArrayKeyValueStructOutput = [string, BigNumber[]] & {
    key: string;
    value: BigNumber[];
  };

  export type UintItemsStruct = {
    items: IEvent.UintKeyValueStruct[];
    arrayItems: IEvent.UintArrayKeyValueStruct[];
  };

  export type UintItemsStructOutput = [
    IEvent.UintKeyValueStructOutput[],
    IEvent.UintArrayKeyValueStructOutput[]
  ] & {
    items: IEvent.UintKeyValueStructOutput[];
    arrayItems: IEvent.UintArrayKeyValueStructOutput[];
  };

  export type IntKeyValueStruct = {
    key: PromiseOrValue<string>;
    value: PromiseOrValue<BigNumberish>;
  };

  export type IntKeyValueStructOutput = [string, BigNumber] & {
    key: string;
    value: BigNumber;
  };

  export type IntArrayKeyValueStruct = {
    key: PromiseOrValue<string>;
    value: PromiseOrValue<BigNumberish>[];
  };

  export type IntArrayKeyValueStructOutput = [string, BigNumber[]] & {
    key: string;
    value: BigNumber[];
  };

  export type IntItemsStruct = {
    items: IEvent.IntKeyValueStruct[];
    arrayItems: IEvent.IntArrayKeyValueStruct[];
  };

  export type IntItemsStructOutput = [
    IEvent.IntKeyValueStructOutput[],
    IEvent.IntArrayKeyValueStructOutput[]
  ] & {
    items: IEvent.IntKeyValueStructOutput[];
    arrayItems: IEvent.IntArrayKeyValueStructOutput[];
  };

  export type BoolKeyValueStruct = {
    key: PromiseOrValue<string>;
    value: PromiseOrValue<boolean>;
  };

  export type BoolKeyValueStructOutput = [string, boolean] & {
    key: string;
    value: boolean;
  };

  export type BoolArrayKeyValueStruct = {
    key: PromiseOrValue<string>;
    value: PromiseOrValue<boolean>[];
  };

  export type BoolArrayKeyValueStructOutput = [string, boolean[]] & {
    key: string;
    value: boolean[];
  };

  export type BoolItemsStruct = {
    items: IEvent.BoolKeyValueStruct[];
    arrayItems: IEvent.BoolArrayKeyValueStruct[];
  };

  export type BoolItemsStructOutput = [
    IEvent.BoolKeyValueStructOutput[],
    IEvent.BoolArrayKeyValueStructOutput[]
  ] & {
    items: IEvent.BoolKeyValueStructOutput[];
    arrayItems: IEvent.BoolArrayKeyValueStructOutput[];
  };

  export type Bytes32KeyValueStruct = {
    key: PromiseOrValue<string>;
    value: PromiseOrValue<BytesLike>;
  };

  export type Bytes32KeyValueStructOutput = [string, string] & {
    key: string;
    value: string;
  };

  export type Bytes32ArrayKeyValueStruct = {
    key: PromiseOrValue<string>;
    value: PromiseOrValue<BytesLike>[];
  };

  export type Bytes32ArrayKeyValueStructOutput = [string, string[]] & {
    key: string;
    value: string[];
  };

  export type Bytes32ItemsStruct = {
    items: IEvent.Bytes32KeyValueStruct[];
    arrayItems: IEvent.Bytes32ArrayKeyValueStruct[];
  };

  export type Bytes32ItemsStructOutput = [
    IEvent.Bytes32KeyValueStructOutput[],
    IEvent.Bytes32ArrayKeyValueStructOutput[]
  ] & {
    items: IEvent.Bytes32KeyValueStructOutput[];
    arrayItems: IEvent.Bytes32ArrayKeyValueStructOutput[];
  };

  export type BytesKeyValueStruct = {
    key: PromiseOrValue<string>;
    value: PromiseOrValue<BytesLike>;
  };

  export type BytesKeyValueStructOutput = [string, string] & {
    key: string;
    value: string;
  };

  export type BytesArrayKeyValueStruct = {
    key: PromiseOrValue<string>;
    value: PromiseOrValue<BytesLike>[];
  };

  export type BytesArrayKeyValueStructOutput = [string, string[]] & {
    key: string;
    value: string[];
  };

  export type BytesItemsStruct = {
    items: IEvent.BytesKeyValueStruct[];
    arrayItems: IEvent.BytesArrayKeyValueStruct[];
  };

  export type BytesItemsStructOutput = [
    IEvent.BytesKeyValueStructOutput[],
    IEvent.BytesArrayKeyValueStructOutput[]
  ] & {
    items: IEvent.BytesKeyValueStructOutput[];
    arrayItems: IEvent.BytesArrayKeyValueStructOutput[];
  };

  export type StringKeyValueStruct = {
    key: PromiseOrValue<string>;
    value: PromiseOrValue<string>;
  };

  export type StringKeyValueStructOutput = [string, string] & {
    key: string;
    value: string;
  };

  export type StringArrayKeyValueStruct = {
    key: PromiseOrValue<string>;
    value: PromiseOrValue<string>[];
  };

  export type StringArrayKeyValueStructOutput = [string, string[]] & {
    key: string;
    value: string[];
  };

  export type StringItemsStruct = {
    items: IEvent.StringKeyValueStruct[];
    arrayItems: IEvent.StringArrayKeyValueStruct[];
  };

  export type StringItemsStructOutput = [
    IEvent.StringKeyValueStructOutput[],
    IEvent.StringArrayKeyValueStructOutput[]
  ] & {
    items: IEvent.StringKeyValueStructOutput[];
    arrayItems: IEvent.StringArrayKeyValueStructOutput[];
  };

  export type EventLogDataStruct = {
    addressItems: IEvent.AddressItemsStruct;
    uintItems: IEvent.UintItemsStruct;
    intItems: IEvent.IntItemsStruct;
    boolItems: IEvent.BoolItemsStruct;
    bytes32Items: IEvent.Bytes32ItemsStruct;
    bytesItems: IEvent.BytesItemsStruct;
    stringItems: IEvent.StringItemsStruct;
  };

  export type EventLogDataStructOutput = [
    IEvent.AddressItemsStructOutput,
    IEvent.UintItemsStructOutput,
    IEvent.IntItemsStructOutput,
    IEvent.BoolItemsStructOutput,
    IEvent.Bytes32ItemsStructOutput,
    IEvent.BytesItemsStructOutput,
    IEvent.StringItemsStructOutput
  ] & {
    addressItems: IEvent.AddressItemsStructOutput;
    uintItems: IEvent.UintItemsStructOutput;
    intItems: IEvent.IntItemsStructOutput;
    boolItems: IEvent.BoolItemsStructOutput;
    bytes32Items: IEvent.Bytes32ItemsStructOutput;
    bytesItems: IEvent.BytesItemsStructOutput;
    stringItems: IEvent.StringItemsStructOutput;
  };
}

export declare namespace IGmxV2Adatper {
  export type PricesStruct = {
    collateralPrice: PromiseOrValue<BigNumberish>;
    indexTokenPrice: PromiseOrValue<BigNumberish>;
    longTokenPrice: PromiseOrValue<BigNumberish>;
    shortTokenPrice: PromiseOrValue<BigNumberish>;
  };

  export type PricesStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    collateralPrice: BigNumber;
    indexTokenPrice: BigNumber;
    longTokenPrice: BigNumber;
    shortTokenPrice: BigNumber;
  };

  export type PendingOrderStruct = {
    key: PromiseOrValue<BytesLike>;
    debtCollateralAmount: PromiseOrValue<BigNumberish>;
    timestamp: PromiseOrValue<BigNumberish>;
    blockNumber: PromiseOrValue<BigNumberish>;
    isIncreasing: PromiseOrValue<boolean>;
  };

  export type PendingOrderStructOutput = [
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    boolean
  ] & {
    key: string;
    debtCollateralAmount: BigNumber;
    timestamp: BigNumber;
    blockNumber: BigNumber;
    isIncreasing: boolean;
  };

  export type AccountStateStruct = {
    owner: PromiseOrValue<string>;
    market: PromiseOrValue<string>;
    indexToken: PromiseOrValue<string>;
    longToken: PromiseOrValue<string>;
    shortToken: PromiseOrValue<string>;
    collateralToken: PromiseOrValue<string>;
    isLong: PromiseOrValue<boolean>;
    debtCollateralAmount: PromiseOrValue<BigNumberish>;
    inflightDebtCollateralAmount: PromiseOrValue<BigNumberish>;
    pendingFeeCollateralAmount: PromiseOrValue<BigNumberish>;
    debtEntryFunding: PromiseOrValue<BigNumberish>;
    isLiquidating: PromiseOrValue<boolean>;
    reserved: PromiseOrValue<BytesLike>[];
  };

  export type AccountStateStructOutput = [
    string,
    string,
    string,
    string,
    string,
    string,
    boolean,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    boolean,
    string[]
  ] & {
    owner: string;
    market: string;
    indexToken: string;
    longToken: string;
    shortToken: string;
    collateralToken: string;
    isLong: boolean;
    debtCollateralAmount: BigNumber;
    inflightDebtCollateralAmount: BigNumber;
    pendingFeeCollateralAmount: BigNumber;
    debtEntryFunding: BigNumber;
    isLiquidating: boolean;
    reserved: string[];
  };

  export type OrderCreateParamsStruct = {
    swapPath: PromiseOrValue<BytesLike>;
    initialCollateralAmount: PromiseOrValue<BigNumberish>;
    tokenOutMinAmount: PromiseOrValue<BigNumberish>;
    borrowCollateralAmount: PromiseOrValue<BigNumberish>;
    sizeDeltaUsd: PromiseOrValue<BigNumberish>;
    triggerPrice: PromiseOrValue<BigNumberish>;
    acceptablePrice: PromiseOrValue<BigNumberish>;
    executionFee: PromiseOrValue<BigNumberish>;
    callbackGasLimit: PromiseOrValue<BigNumberish>;
    orderType: PromiseOrValue<BigNumberish>;
  };

  export type OrderCreateParamsStructOutput = [
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    number
  ] & {
    swapPath: string;
    initialCollateralAmount: BigNumber;
    tokenOutMinAmount: BigNumber;
    borrowCollateralAmount: BigNumber;
    sizeDeltaUsd: BigNumber;
    triggerPrice: BigNumber;
    acceptablePrice: BigNumber;
    executionFee: BigNumber;
    callbackGasLimit: BigNumber;
    orderType: number;
  };
}

export interface GmxV2AdapterInterface extends utils.Interface {
  functions: {
    "afterOrderCancellation(bytes32,((address,address,address,address,address,address,address[]),(uint8,uint8,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),(bool,bool,bool)),(((string,address)[],(string,address[])[]),((string,uint256)[],(string,uint256[])[]),((string,int256)[],(string,int256[])[]),((string,bool)[],(string,bool[])[]),((string,bytes32)[],(string,bytes32[])[]),((string,bytes)[],(string,bytes[])[]),((string,string)[],(string,string[])[])))": FunctionFragment;
    "afterOrderExecution(bytes32,((address,address,address,address,address,address,address[]),(uint8,uint8,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),(bool,bool,bool)),(((string,address)[],(string,address[])[]),((string,uint256)[],(string,uint256[])[]),((string,int256)[],(string,int256[])[]),((string,bool)[],(string,bool[])[]),((string,bytes32)[],(string,bytes32[])[]),((string,bytes)[],(string,bytes[])[]),((string,string)[],(string,string[])[])))": FunctionFragment;
    "afterOrderFrozen(bytes32,((address,address,address,address,address,address,address[]),(uint8,uint8,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),(bool,bool,bool)),(((string,address)[],(string,address[])[]),((string,uint256)[],(string,uint256[])[]),((string,int256)[],(string,int256[])[]),((string,bool)[],(string,bool[])[]),((string,bytes32)[],(string,bytes32[])[]),((string,bytes)[],(string,bytes[])[]),((string,string)[],(string,string[])[])))": FunctionFragment;
    "cancelExpiredOrder(bytes32)": FunctionFragment;
    "cancelOrder(bytes32)": FunctionFragment;
    "claimFundingFees(address[],address[])": FunctionFragment;
    "claimNativeToken()": FunctionFragment;
    "claimToken(address)": FunctionFragment;
    "getMarginRate((uint256,uint256,uint256,uint256))": FunctionFragment;
    "getPendingOrders()": FunctionFragment;
    "initialize(uint256,address,address,address,address,bool)": FunctionFragment;
    "isLiquidateable((uint256,uint256,uint256,uint256))": FunctionFragment;
    "liquidatePosition((uint256,uint256,uint256,uint256),uint256,uint256)": FunctionFragment;
    "muxAccountState()": FunctionFragment;
    "placeOrder((bytes,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint8))": FunctionFragment;
    "positionKey()": FunctionFragment;
    "updateOrder(bytes32,uint256,uint256,uint256)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "afterOrderCancellation"
      | "afterOrderExecution"
      | "afterOrderFrozen"
      | "cancelExpiredOrder"
      | "cancelOrder"
      | "claimFundingFees"
      | "claimNativeToken"
      | "claimToken"
      | "getMarginRate"
      | "getPendingOrders"
      | "initialize"
      | "isLiquidateable"
      | "liquidatePosition"
      | "muxAccountState"
      | "placeOrder"
      | "positionKey"
      | "updateOrder"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "afterOrderCancellation",
    values: [
      PromiseOrValue<BytesLike>,
      IOrder.PropsStruct,
      IEvent.EventLogDataStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "afterOrderExecution",
    values: [
      PromiseOrValue<BytesLike>,
      IOrder.PropsStruct,
      IEvent.EventLogDataStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "afterOrderFrozen",
    values: [
      PromiseOrValue<BytesLike>,
      IOrder.PropsStruct,
      IEvent.EventLogDataStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelExpiredOrder",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelOrder",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "claimFundingFees",
    values: [PromiseOrValue<string>[], PromiseOrValue<string>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "claimNativeToken",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "claimToken",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getMarginRate",
    values: [IGmxV2Adatper.PricesStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "getPendingOrders",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "isLiquidateable",
    values: [IGmxV2Adatper.PricesStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "liquidatePosition",
    values: [
      IGmxV2Adatper.PricesStruct,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "muxAccountState",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "placeOrder",
    values: [IGmxV2Adatper.OrderCreateParamsStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "positionKey",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "updateOrder",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;

  decodeFunctionResult(
    functionFragment: "afterOrderCancellation",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "afterOrderExecution",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "afterOrderFrozen",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelExpiredOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "claimFundingFees",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "claimNativeToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "claimToken", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getMarginRate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getPendingOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isLiquidateable",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "liquidatePosition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "muxAccountState",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "placeOrder", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "positionKey",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateOrder",
    data: BytesLike
  ): Result;

  events: {
    "Initialized(uint8)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "Initialized"): EventFragment;
}

export interface InitializedEventObject {
  version: number;
}
export type InitializedEvent = TypedEvent<[number], InitializedEventObject>;

export type InitializedEventFilter = TypedEventFilter<InitializedEvent>;

export interface GmxV2Adapter extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: GmxV2AdapterInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    afterOrderCancellation(
      key: PromiseOrValue<BytesLike>,
      arg1: IOrder.PropsStruct,
      arg2: IEvent.EventLogDataStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    afterOrderExecution(
      key: PromiseOrValue<BytesLike>,
      arg1: IOrder.PropsStruct,
      arg2: IEvent.EventLogDataStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    afterOrderFrozen(
      key: PromiseOrValue<BytesLike>,
      arg1: IOrder.PropsStruct,
      arg2: IEvent.EventLogDataStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    cancelExpiredOrder(
      key: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    cancelOrder(
      key: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    claimFundingFees(
      markets: PromiseOrValue<string>[],
      tokens: PromiseOrValue<string>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    claimNativeToken(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    claimToken(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getMarginRate(
      prices: IGmxV2Adatper.PricesStruct,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getPendingOrders(
      overrides?: CallOverrides
    ): Promise<
      [IGmxV2Adatper.PendingOrderStructOutput[]] & {
        pendingOrders: IGmxV2Adatper.PendingOrderStructOutput[];
      }
    >;

    initialize(
      projectId_: PromiseOrValue<BigNumberish>,
      liquidityPool: PromiseOrValue<string>,
      owner: PromiseOrValue<string>,
      collateralToken: PromiseOrValue<string>,
      market: PromiseOrValue<string>,
      isLong: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    isLiquidateable(
      prices: IGmxV2Adatper.PricesStruct,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    liquidatePosition(
      prices: IGmxV2Adatper.PricesStruct,
      executionFee: PromiseOrValue<BigNumberish>,
      callbackGasLimit: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    muxAccountState(
      overrides?: CallOverrides
    ): Promise<[IGmxV2Adatper.AccountStateStructOutput]>;

    placeOrder(
      createParams: IGmxV2Adatper.OrderCreateParamsStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    positionKey(overrides?: CallOverrides): Promise<[string]>;

    updateOrder(
      key: PromiseOrValue<BytesLike>,
      sizeDeltaUsd: PromiseOrValue<BigNumberish>,
      acceptablePrice: PromiseOrValue<BigNumberish>,
      triggerPrice: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  afterOrderCancellation(
    key: PromiseOrValue<BytesLike>,
    arg1: IOrder.PropsStruct,
    arg2: IEvent.EventLogDataStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  afterOrderExecution(
    key: PromiseOrValue<BytesLike>,
    arg1: IOrder.PropsStruct,
    arg2: IEvent.EventLogDataStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  afterOrderFrozen(
    key: PromiseOrValue<BytesLike>,
    arg1: IOrder.PropsStruct,
    arg2: IEvent.EventLogDataStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  cancelExpiredOrder(
    key: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  cancelOrder(
    key: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  claimFundingFees(
    markets: PromiseOrValue<string>[],
    tokens: PromiseOrValue<string>[],
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  claimNativeToken(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  claimToken(
    token: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getMarginRate(
    prices: IGmxV2Adatper.PricesStruct,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getPendingOrders(
    overrides?: CallOverrides
  ): Promise<IGmxV2Adatper.PendingOrderStructOutput[]>;

  initialize(
    projectId_: PromiseOrValue<BigNumberish>,
    liquidityPool: PromiseOrValue<string>,
    owner: PromiseOrValue<string>,
    collateralToken: PromiseOrValue<string>,
    market: PromiseOrValue<string>,
    isLong: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  isLiquidateable(
    prices: IGmxV2Adatper.PricesStruct,
    overrides?: CallOverrides
  ): Promise<boolean>;

  liquidatePosition(
    prices: IGmxV2Adatper.PricesStruct,
    executionFee: PromiseOrValue<BigNumberish>,
    callbackGasLimit: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  muxAccountState(
    overrides?: CallOverrides
  ): Promise<IGmxV2Adatper.AccountStateStructOutput>;

  placeOrder(
    createParams: IGmxV2Adatper.OrderCreateParamsStruct,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  positionKey(overrides?: CallOverrides): Promise<string>;

  updateOrder(
    key: PromiseOrValue<BytesLike>,
    sizeDeltaUsd: PromiseOrValue<BigNumberish>,
    acceptablePrice: PromiseOrValue<BigNumberish>,
    triggerPrice: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    afterOrderCancellation(
      key: PromiseOrValue<BytesLike>,
      arg1: IOrder.PropsStruct,
      arg2: IEvent.EventLogDataStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    afterOrderExecution(
      key: PromiseOrValue<BytesLike>,
      arg1: IOrder.PropsStruct,
      arg2: IEvent.EventLogDataStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    afterOrderFrozen(
      key: PromiseOrValue<BytesLike>,
      arg1: IOrder.PropsStruct,
      arg2: IEvent.EventLogDataStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    cancelExpiredOrder(
      key: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    cancelOrder(
      key: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    claimFundingFees(
      markets: PromiseOrValue<string>[],
      tokens: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    claimNativeToken(overrides?: CallOverrides): Promise<BigNumber>;

    claimToken(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getMarginRate(
      prices: IGmxV2Adatper.PricesStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getPendingOrders(
      overrides?: CallOverrides
    ): Promise<IGmxV2Adatper.PendingOrderStructOutput[]>;

    initialize(
      projectId_: PromiseOrValue<BigNumberish>,
      liquidityPool: PromiseOrValue<string>,
      owner: PromiseOrValue<string>,
      collateralToken: PromiseOrValue<string>,
      market: PromiseOrValue<string>,
      isLong: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    isLiquidateable(
      prices: IGmxV2Adatper.PricesStruct,
      overrides?: CallOverrides
    ): Promise<boolean>;

    liquidatePosition(
      prices: IGmxV2Adatper.PricesStruct,
      executionFee: PromiseOrValue<BigNumberish>,
      callbackGasLimit: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    muxAccountState(
      overrides?: CallOverrides
    ): Promise<IGmxV2Adatper.AccountStateStructOutput>;

    placeOrder(
      createParams: IGmxV2Adatper.OrderCreateParamsStruct,
      overrides?: CallOverrides
    ): Promise<string>;

    positionKey(overrides?: CallOverrides): Promise<string>;

    updateOrder(
      key: PromiseOrValue<BytesLike>,
      sizeDeltaUsd: PromiseOrValue<BigNumberish>,
      acceptablePrice: PromiseOrValue<BigNumberish>,
      triggerPrice: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "Initialized(uint8)"(version?: null): InitializedEventFilter;
    Initialized(version?: null): InitializedEventFilter;
  };

  estimateGas: {
    afterOrderCancellation(
      key: PromiseOrValue<BytesLike>,
      arg1: IOrder.PropsStruct,
      arg2: IEvent.EventLogDataStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    afterOrderExecution(
      key: PromiseOrValue<BytesLike>,
      arg1: IOrder.PropsStruct,
      arg2: IEvent.EventLogDataStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    afterOrderFrozen(
      key: PromiseOrValue<BytesLike>,
      arg1: IOrder.PropsStruct,
      arg2: IEvent.EventLogDataStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    cancelExpiredOrder(
      key: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    cancelOrder(
      key: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    claimFundingFees(
      markets: PromiseOrValue<string>[],
      tokens: PromiseOrValue<string>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    claimNativeToken(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    claimToken(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getMarginRate(
      prices: IGmxV2Adatper.PricesStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getPendingOrders(overrides?: CallOverrides): Promise<BigNumber>;

    initialize(
      projectId_: PromiseOrValue<BigNumberish>,
      liquidityPool: PromiseOrValue<string>,
      owner: PromiseOrValue<string>,
      collateralToken: PromiseOrValue<string>,
      market: PromiseOrValue<string>,
      isLong: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    isLiquidateable(
      prices: IGmxV2Adatper.PricesStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    liquidatePosition(
      prices: IGmxV2Adatper.PricesStruct,
      executionFee: PromiseOrValue<BigNumberish>,
      callbackGasLimit: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    muxAccountState(overrides?: CallOverrides): Promise<BigNumber>;

    placeOrder(
      createParams: IGmxV2Adatper.OrderCreateParamsStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    positionKey(overrides?: CallOverrides): Promise<BigNumber>;

    updateOrder(
      key: PromiseOrValue<BytesLike>,
      sizeDeltaUsd: PromiseOrValue<BigNumberish>,
      acceptablePrice: PromiseOrValue<BigNumberish>,
      triggerPrice: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    afterOrderCancellation(
      key: PromiseOrValue<BytesLike>,
      arg1: IOrder.PropsStruct,
      arg2: IEvent.EventLogDataStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    afterOrderExecution(
      key: PromiseOrValue<BytesLike>,
      arg1: IOrder.PropsStruct,
      arg2: IEvent.EventLogDataStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    afterOrderFrozen(
      key: PromiseOrValue<BytesLike>,
      arg1: IOrder.PropsStruct,
      arg2: IEvent.EventLogDataStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    cancelExpiredOrder(
      key: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    cancelOrder(
      key: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    claimFundingFees(
      markets: PromiseOrValue<string>[],
      tokens: PromiseOrValue<string>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    claimNativeToken(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    claimToken(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getMarginRate(
      prices: IGmxV2Adatper.PricesStruct,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getPendingOrders(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    initialize(
      projectId_: PromiseOrValue<BigNumberish>,
      liquidityPool: PromiseOrValue<string>,
      owner: PromiseOrValue<string>,
      collateralToken: PromiseOrValue<string>,
      market: PromiseOrValue<string>,
      isLong: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    isLiquidateable(
      prices: IGmxV2Adatper.PricesStruct,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    liquidatePosition(
      prices: IGmxV2Adatper.PricesStruct,
      executionFee: PromiseOrValue<BigNumberish>,
      callbackGasLimit: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    muxAccountState(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    placeOrder(
      createParams: IGmxV2Adatper.OrderCreateParamsStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    positionKey(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    updateOrder(
      key: PromiseOrValue<BytesLike>,
      sizeDeltaUsd: PromiseOrValue<BigNumberish>,
      acceptablePrice: PromiseOrValue<BigNumberish>,
      triggerPrice: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
